<!-- build time:Fri Sep 23 2022 22:46:45 GMT+0800 (GMT+08:00) --><!DOCTYPE html><html class="theme-next gemini use-motion" lang="zh-Hans"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><script data-ad-client="ca-pub-7534416172769714" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/theme-next/theme-next-needmoreshare2@1/needsharebutton.min.css"><script src="//cdn.jsdelivr.net/npm/pace-js@1/pace.min.js"></script><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/pace-js@1/themes/blue/pace-theme-minimal.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4/css/font-awesome.min.css"><link rel="stylesheet" href="/css/main.css?v=7.1.2"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.1.2"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.1.2"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.1.2"><link rel="mask-icon" href="/images/logo.svg?v=7.1.2" color="#222"><script id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Gemini",version:"7.1.2",sidebar:{position:"left",display:"post",offset:12,onmobile:!1,dimmer:!0},back2top:!0,back2top_sidebar:!0,fancybox:!0,fastclick:!0,lazyload:!0,tabs:!0,motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><meta name="description" content="JAVA SE准备概念名词说明JAVA SEJAVA 标准版。JAVA EEJAVA 企业版本（开发动态网站）。JDKJAVA 开发工具包，包含 JRE。JREJAVA 运行环境。jdk 目录说明目录说明bin（二进制）存放 java 字节码文件。db数据库。lib存放 Java 类库文件。include存放用于本地方法文件的文件。demo（另行下载）存放演示文件。jre存放Java运行环境文件。"><meta name="keywords" content="JAVA"><meta property="og:type" content="article"><meta property="og:title" content="JAVA"><meta property="og:url" content="https://zero3737.gitee.io/posts/40121/index.html"><meta property="og:site_name" content="im乐"><meta property="og:description" content="JAVA SE准备概念名词说明JAVA SEJAVA 标准版。JAVA EEJAVA 企业版本（开发动态网站）。JDKJAVA 开发工具包，包含 JRE。JREJAVA 运行环境。jdk 目录说明目录说明bin（二进制）存放 java 字节码文件。db数据库。lib存放 Java 类库文件。include存放用于本地方法文件的文件。demo（另行下载）存放演示文件。jre存放Java运行环境文件。"><meta property="og:locale" content="zh-Hans"><meta property="og:image" content="https://ftp.bmp.ovh/imgs/2019/08/463b74f379e33155.png"><meta property="og:updated_time" content="2020-04-07T09:37:49.316Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="JAVA"><meta name="twitter:description" content="JAVA SE准备概念名词说明JAVA SEJAVA 标准版。JAVA EEJAVA 企业版本（开发动态网站）。JDKJAVA 开发工具包，包含 JRE。JREJAVA 运行环境。jdk 目录说明目录说明bin（二进制）存放 java 字节码文件。db数据库。lib存放 Java 类库文件。include存放用于本地方法文件的文件。demo（另行下载）存放演示文件。jre存放Java运行环境文件。"><meta name="twitter:image" content="https://ftp.bmp.ovh/imgs/2019/08/463b74f379e33155.png"><link rel="alternate" href="/atom.xml" title="im乐" type="application/atom+xml"><link rel="canonical" href="https://zero3737.gitee.io/posts/40121/"><script id="page.configurations">CONFIG.page={sidebar:""}</script><title>JAVA | im乐</title><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?4082c5f4a737e261906898d7d41f122b";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-title,.use-motion .comments,.use-motion .menu-item,.use-motion .motion-element,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .logo,.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">im乐</span> <span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle">Efforts may not lead to success, but please don't be discouraged</p></div><div class="site-nav-toggle"><button aria-label="切换导航栏"><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>归档</a></li><li class="menu-item menu-item-search"><a href="javascript:;" class="popup-trigger"><i class="menu-item-icon fa fa-search fa-fw"></i><br>搜索</a></li></ul><div class="site-search"><div class="popup search-popup local-search-popup"><div class="local-search-header clearfix"><span class="search-icon"><i class="fa fa-search"></i> </span><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span><div class="local-search-input-wrapper"><input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input"></div></div><div id="local-search-result"></div></div></div></nav></div><link rel="stylesheet" href="/live2d/css/live2d.css"></header><a href="https://github.com/zero3737" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="noopener" target="_blank"><svg width="80" height="80" viewbox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"/><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"/><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"/></svg></a><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><div class="reading-progress-bar"></div><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://zero3737.gitee.io/posts/40121/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="im乐"><meta itemprop="description" content="一个专注分享互联网知识的网站，希望你会喜欢它。"><meta itemprop="image" content="/static/user_images/头像/avatar.gif"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="im乐"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">JAVA</h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2019-04-01 15:39:25" itemprop="dateCreated datePublished" datetime="2019-04-01T15:39:25+08:00">2019-04-01</time> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2020-04-07 17:37:49" itemprop="dateModified" datetime="2020-04-07T17:37:49+08:00">2020-04-07</time> </span><span class="post-comments-count"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-comment-o"></i> </span><span class="post-meta-item-text">评论数：</span> <a href="/posts/40121/#comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/posts/40121/" itemprop="commentCount"></span> </a></span><span id="/posts/40121/" class="leancloud_visitors" data-flag-title="JAVA"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span class="leancloud-visitors-count"></span></span><div class="post-symbolscount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i> </span><span class="post-meta-item-text">本文字数：</span> <span title="本文字数">32k</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span title="阅读时长">29 分钟</span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="JAVA-SE"><a href="#JAVA-SE" class="headerlink" title="JAVA SE"></a>JAVA SE</h1><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><table><thead><tr><th align="left">名词</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">JAVA SE</td><td align="left">JAVA 标准版。</td></tr><tr><td align="left">JAVA EE</td><td align="left">JAVA 企业版本（开发动态网站）。</td></tr><tr><td align="left">JDK</td><td align="left">JAVA 开发工具包，包含 JRE。</td></tr><tr><td align="left">JRE</td><td align="left">JAVA 运行环境。</td></tr></tbody></table><h3 id="jdk-目录说明"><a href="#jdk-目录说明" class="headerlink" title="jdk 目录说明"></a>jdk 目录说明</h3><table><thead><tr><th align="left">目录</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">bin（二进制）</td><td align="left">存放 java 字节码文件。</td></tr><tr><td align="left">db</td><td align="left">数据库。</td></tr><tr><td align="left">lib</td><td align="left">存放 Java 类库文件。</td></tr><tr><td align="left">include</td><td align="left">存放用于本地方法文件的文件。</td></tr><tr><td align="left">demo（另行下载）</td><td align="left">存放演示文件。</td></tr><tr><td align="left">jre</td><td align="left">存放Java运行环境文件。</td></tr></tbody></table><a id="more"></a><h3 id="配置-JAVA-环境"><a href="#配置-JAVA-环境" class="headerlink" title="配置 JAVA 环境"></a>配置 JAVA 环境</h3><table><thead><tr><th align="left">变量</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">PATH</td><td align="left">jdk 中 bin 目录（最简配置）。</td></tr><tr><td align="left">JAVA_HOME</td><td align="left">jdk 目录（用于配置相对路径）。</td></tr><tr><td align="left">CLASSPATH</td><td align="left">1. 编译、运行 Java 程序时，JRE 会去该变量指定的路径中搜索所需的类（.class）文件。<br>2. CLASSPATH 普通配置：<code>.;%JAVA_HOME%\lib;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar</code><br>3. 在 JDK9 后，它的lib目录中都已经不包含 dt.jar 和 tool.jar 这两个包了<br>4. 而 <code>.</code> 的搜索当前路径下的 class 文件这个功能，不去设置 CLASSPATH 的话，这就是它的默认搜索路径。</td></tr></tbody></table><h3 id="手动编译"><a href="#手动编译" class="headerlink" title="手动编译"></a>手动编译</h3><table><thead><tr><th align="left">cmd 命令</th><th align="left">功能</th></tr></thead><tbody><tr><td align="left">java –version</td><td align="left">查看 java 版本。</td></tr><tr><td align="left">javac file.java</td><td align="left">编译命令，编译成 <code>.class</code> 字节码文件。</td></tr><tr><td align="left">java file</td><td align="left">运行 class 文件，不需要指定 class 后缀。</td></tr></tbody></table><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="class"><a href="#class" class="headerlink" title="class"></a>class</h3><p>class 后面必须紧跟类名且不能包含任何关键字，表示定义一个类。</p><h3 id="包机制"><a href="#包机制" class="headerlink" title="包机制"></a>包机制</h3><h4 id="package"><a href="#package" class="headerlink" title="package"></a>package</h4><ul><li>包机制为了防止命名冲突，访问控制，提供搜索和定位类、接口、枚举和注释。</li><li>同一个包中的类名字是不同的，不同的包中的类的名字是可以相同的。</li><li>当同时调用两个不同包中相同类名的类时，应该加上包名加以区别。</li><li>包声明应该在源文件的第一行，每个源文件只能有一个包声明。</li><li>包语句语法格式：<code>c pkg1[．pkg2[．pkg3…]];</code></li><li>假如包路径为 <code>package net.java.util;</code> 那么源文件存放路径为 <code>net/java/util/Something.java</code>。</li><li>一个公司使用它互联网域名的颠倒形式来作为它的包名。</li></ul><h4 id="import"><a href="#import" class="headerlink" title="import"></a>import</h4><ul><li>import 语句应位于 package 语句之后，所有类的定义之前，可以没有，也可以有多条。</li><li>语法格式：<code>import package1[.package2…].(classname|*);</code></li><li>如果在一个包中，一个类想要使用本包中的另一个类，可省略 import 语句。</li></ul><h3 id="Object-类"><a href="#Object-类" class="headerlink" title="Object 类"></a>Object 类</h3><ul><li>java 默认引用 java.lang 包。</li><li>Object 是所有 java 类的父类，要么是直接继承要么是间接继承。</li><li>直接打印普通类，默认输出 hashcode 十六进制的值（输出 Object 类的 toString 方法）。</li></ul><h3 id="汉字编码"><a href="#汉字编码" class="headerlink" title="汉字编码"></a>汉字编码</h3><p>汉字以 unicode 编码存放，汉字也可以进行排序，但是没有意义。</p><h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><table><thead><tr><th align="left">名词</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">内存泄漏</td><td align="left">程序中己动态分配的堆内存由于某种原因未释放或无法释放，造成系统内存的浪费。</td></tr><tr><td align="left">内存溢出</td><td align="left">程序在申请内存时，没有足够的内存空间供其使用。</td></tr><tr><td align="left">内存越界</td><td align="left">向系统申请一块内存后，使用时超出申请范围。</td></tr><tr><td align="left">缓冲区溢出</td><td align="left">向缓冲区内填充数据时超过了缓冲区本身的容量，而导致数据溢出并覆盖了其他内存空间的数据。</td></tr><tr><td align="left">栈溢出</td><td align="left">1. 是缓冲区溢出的一种，分为上溢出和下溢出。<br>2. 上溢出是指栈满而又向其增加新的数据，导致数据溢出。<br>3. 下溢出是指空栈而又进行删除操作，导致空间溢出。</td></tr></tbody></table><h3 id="GC-垃圾回收机制"><a href="#GC-垃圾回收机制" class="headerlink" title="GC 垃圾回收机制"></a>GC 垃圾回收机制</h3><ul><li>java 是自动垃圾回收机制。</li><li>程序员不需要再动手控制内存的释放。</li><li>当 jvm 发现内存资源紧张的时候，会自动的清理无用的对象。</li><li><code>System.gc();</code> 此方法可以立即运行 gc 垃圾回收器。</li></ul><h3 id="输出输入"><a href="#输出输入" class="headerlink" title="输出输入"></a>输出输入</h3><h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><ul><li>System.out.println 打印（print）并换行（line）。</li><li>如果直接打印对象且该对象没有覆盖 Object 类的 toString 方法会打印 <code>包名.类名@十六进制的hashCode</code> 形式。</li></ul><h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Scanner reader = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">reader.nextInt();	<span class="comment">// 读入一个整型数据。</span></span><br><span class="line">reader.nextFloat();	<span class="comment">// 读入一个单精度浮点型。</span></span><br><span class="line">reader.nextLine();	<span class="comment">// 读入一个字符串。</span></span><br></pre></td></tr></table></figure><h2 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h2><h3 id="默认长度"><a href="#默认长度" class="headerlink" title="默认长度"></a>默认长度</h3><table><thead><tr><th align="left">类型</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">整型</td><td align="left">int（32位）、short（16位）、long（64位）、byte（8位，字节类型）、char（16位）</td></tr><tr><td align="left">浮点型</td><td align="left">1. float（32位，小数点7位）、double（64位，小数点16位）<br>2. float后面数值加f（相当于强制类型转换，浮点型默认double类型）。</td></tr><tr><td align="left">非数值</td><td align="left">booleam（8位，布尔类型）、String（类）</td></tr></tbody></table><h3 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h3><table><thead><tr><th align="left">基本类型</th><th align="left">默认值</th></tr></thead><tbody><tr><td align="left">byte</td><td align="left">0</td></tr><tr><td align="left">short</td><td align="left">0</td></tr><tr><td align="left">int</td><td align="left">0</td></tr><tr><td align="left">long</td><td align="left">0</td></tr><tr><td align="left">float</td><td align="left">0.0</td></tr><tr><td align="left">double</td><td align="left">0.0</td></tr><tr><td align="left">char</td><td align="left">‘\u0000’</td></tr><tr><td align="left">boolean</td><td align="left">false</td></tr></tbody></table><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>静态初始化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] 数组名称 = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>[] 数组名称 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;               <span class="comment">// 与上面的效果相同，只是简写了上面的内容。</span></span><br><span class="line"><span class="keyword">int</span>[] 数组名称 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1024</span>] &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;; <span class="comment">//错误，静态初始化不能指定数组容量。</span></span><br></pre></td></tr></table></figure><p>动态初始化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] 数组名称 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100</span>];</span><br></pre></td></tr></table></figure><h3 id="Arrays-类"><a href="#Arrays-类" class="headerlink" title="Arrays 类"></a>Arrays 类</h3><table><thead><tr><th align="left">方法</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">Arrays.toString(数组名)</td><td align="left">输出数组内容。</td></tr><tr><td align="left">Arrays.asList(数组名称)</td><td align="left">将数组转换成 list 集合。</td></tr><tr><td align="left">Arrays.sort(数组引用)</td><td align="left">对数组中的元素按照升序排序。</td></tr></tbody></table><h3 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h3><p>可变参数定义：数据类型…数组名称。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span>...args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">		</span><br><span class="line">		result += args[i];</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	System.out.println(result);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] params = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line">sum(params);</span><br><span class="line">sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br></pre></td></tr></table></figure><p>可变参数是数组参数的一种简写，可变参数相当于：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> args[])</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line"></span><br><span class="line">		result += args[i];</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">	System.out.println(result);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数值类型转换"><a href="#数值类型转换" class="headerlink" title="数值类型转换"></a>数值类型转换</h2><h3 id="自动类型转换"><a href="#自动类型转换" class="headerlink" title="自动类型转换"></a>自动类型转换</h3><ul><li>运算时，运算两端的数据类型必须要保持一致。</li><li>如果运算都为数值类型，会自动把小的数据类型转换为大的数据类型。</li><li>不能把一个大的数值类型赋值给小的类型，比如：int 类型变量不能赋值给 byte 类型变量。</li><li>而 byte 类型变量可以直接赋值给 int 类型的变量。</li></ul><h3 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h3><p>强制类型转换容易造成数据的溢出，比如：long 类型变量赋值给 int 类型变量。</p><h2 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h2><ul><li>在一个作用域（一对花括号为一个作用域）中，要给变量赋另一个变量，它会先到当前作用域中去找是否存在指定变量。</li><li>如果有，就给作用域中的变量直接赋值，不会再往上去找。</li><li>如果没有，就往上一层作用域去找。</li></ul><h2 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h2><h3 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h3><p>foreach 遍历数组，是一种简写方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] num = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i : num) &#123;</span><br><span class="line"></span><br><span class="line">	System.out.println(i);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 相当于</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; num.length; i++)&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> i = num[j];</span><br><span class="line">	System.out.println(i);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>foreach 可以遍历数组和集合。</li><li>规定不能在 foreach 循环中增删操作。</li></ul><h3 id="退出外层循环"><a href="#退出外层循环" class="headerlink" title="退出外层循环"></a>退出外层循环</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">outter: <span class="keyword">for</span>()&#123;</span><br><span class="line"></span><br><span class="line">    inner:<span class="keyword">for</span>()&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">break</span> outter;   <span class="comment">// 退出outter循环</span></span><br><span class="line">        <span class="keyword">break</span> inner;    <span class="comment">// 退出inner循环</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>outter 和 inner 分别为 for 循环别名。</li></ul><h2 id="final"><a href="#final" class="headerlink" title="final"></a>final</h2><ul><li>final 修饰变量表示其值不能改变。</li><li>final 修饰方法表示方法不能重写。</li><li>final 关键修饰类的时候，表示这个类不能被继承。</li><li>final 修饰引用表示指向的地址不能改变，即对象不能改变。</li><li>用 final 修饰的变量存放在方法区，方法区的声明周期直到 jvm 关闭。</li></ul><h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><ul><li>static 只能修饰类中的成员属性和方法，也不能在方法中使用 static 修饰符。</li><li>static 不能修饰普通类，但可以修饰普通类中的内部类。</li><li>static 用来声明独立于对象的静态成员，无论一个类实例化多少对象，它的静态成员只有一份拷贝。</li><li>static 修饰的变量在项目启动时就分配内存，直到程序结束。</li><li>static 修饰的方法在被调用的时候才分配内存。</li><li>静态方法只能访问静态成员，就算用 final 修饰的成员也不能访问。</li><li>静态方法中定义的变量不是静态的，返回值是静态的。</li><li>static 修饰的属性和方法放在方法区，而基本数据类型是存放在栈区的。</li></ul><h3 id="静态代码块"><a href="#静态代码块" class="headerlink" title="静态代码块"></a>静态代码块</h3><ul><li>当类被加载的时候就会执行静态代码块。</li><li>类被加载的意思是使用 new 关键字。</li><li>new 一个对象就是在堆内存中开辟一块内存。</li><li>类只会被加载一次到内存中，下一次直接从内存中使用。</li><li>静态字段是在静态代码块中初始化，非静态字段是在构造方法中初始化。</li></ul><h2 id="this-指针"><a href="#this-指针" class="headerlink" title="this 指针"></a>this 指针</h2><p>在一个类中，方法不是静态方法，可以直接调用本类中的其他方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">people</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        show(); <span class="comment">//相当于this.show();</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="this-说明"><a href="#this-说明" class="headerlink" title="this 说明"></a>this 说明</h3><ul><li>this 只能在类中使用，表示当前对象。</li><li>this 可以作为返回值，表示返回当前对象。</li><li>静态方法没有 this 指针，也就是说不能在静态方法中使用 this 关键字。</li></ul><h3 id="super"><a href="#super" class="headerlink" title="super"></a>super</h3><ul><li>super 指向父类对象的地址。</li><li>this 和 super 可以调用构造方法，如果构造方法复用，this 和 super 必须放在第一行。</li><li>this 和 super 不能混合使用。</li><li>父类的成员属性一般是私有的，可以通过调用父类的构造函数初始化父类的私有属性。</li></ul><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><ul><li>无论父类中的成员变量是私有的、共有的、还是其它类型的，子类都会拥有父类中的这些成员变量。</li><li>但是父类中的私有成员变量，无法在子类中直接访问。</li><li>必须通过从父类中继承得到的 protected、public 方法（如 getter、setter 方法）来访问私有成员。</li><li>无论父类中的成员变量是静态的、还是非静态的，子类都会拥有父类中的这些成员变量。</li><li>无论父类中的成员变量是否被子类覆盖，子类都会拥有父类中的这些成员变量。</li><li>继承父类时，子类的访问权限要比父类的大或一样大，不能比父类权限小。</li></ul><h3 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h3><table><thead><tr><th align="left">关系</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">基类</td><td align="left">父类的别称。</td></tr><tr><td align="left">派生类</td><td align="left">子类的别称。</td></tr></tbody></table><h3 id="访问权限"><a href="#访问权限" class="headerlink" title="访问权限"></a>访问权限</h3><table><thead><tr><th align="left">访问权限</th><th align="left">子类能否访问</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">public</td><td align="left">能</td><td align="left"></td></tr><tr><td align="left">默认</td><td align="left">能</td><td align="left">同一个包中的子类可以访问，不同包中的子类不能访问。</td></tr><tr><td align="left">protected</td><td align="left">能</td><td align="left"></td></tr><tr><td align="left">private</td><td align="left">不能</td><td align="left"></td></tr></tbody></table><h3 id="类的类型转换"><a href="#类的类型转换" class="headerlink" title="类的类型转换"></a>类的类型转换</h3><ul><li><p>把父类对象赋值给子类引用，需要强制类型转换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Dog dog = (Dog)anim;	<span class="comment">// Animal 为 Dog 的父类，anim 为 Anima 类型的实例。</span></span><br></pre></td></tr></table></figure></li><li><p>而子类对象赋值给父类引用不需要强制类型转换。</p></li><li><p>只有存在父子关系才可以类型转换，子类之间不能相互转换。</p></li><li><p>为什么子类对象赋值给父类引用不需要强制类型转换？</p><ul><li>父类引用接受不同子类实例，表现为多态性。</li><li>子类继承父类，它含有父类部分。</li><li>如果子类对象赋值给父类引用，则使用该变量只能访问子类的父类部分，因为子类含有父类的部分。</li><li>如果反过来，子类引用访问父类的扩充成员变量，就会访问不到，因为原变量不包含该部分（内存越界）。</li></ul></li></ul><h3 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h3><ul><li><p>判断对象是否为指定类的实例，返回布尔类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> result = obj <span class="keyword">instanceof</span> Class;</span><br></pre></td></tr></table></figure></li><li><p>也可以判断对象是否为指定类的子类实例。</p></li><li><p>也可以判断对象是否实现对应接口。</p></li></ul><h3 id="重写和重载"><a href="#重写和重载" class="headerlink" title="重写和重载"></a>重写和重载</h3><h4 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h4><ul><li>重写是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。</li><li>重写方法不能抛出新的检查异常或者比被重写方法申明更加宽泛的异常。</li><li>返回类型与被重写方法的返回类型可以不相同，但是必须是父类返回值的派生类（JAVA7 特性）。</li><li>访问权限不能比父类中被重写的方法的访问权限更低。</li><li>声明为 final 的方法不能被重写。</li><li>声明为 static 的方法不能被重写，但是能够被再次声明（static 修饰的方法或属性属于类）。</li><li>构造方法不能被重写。</li></ul><h4 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h4><ul><li>重载是在一个类里面，方法名字相同，而参数不同，返回类型可以相同也可以不同。</li><li>被重载的方法必须改变参数列表(参数个数或类型不一样)。</li><li>方法能够在同一个类中或者在一个子类中被重载。</li><li>被重载的方法可以改变返回类型。</li><li>无法以返回值类型作为重载函数的区分标准。</li></ul><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><ul><li>多态是同一个行为具有多个不同表现形式或形态的能力。</li><li>多态就是同一个接口，使用不同的实例而执行不同操作。</li><li>或父类引用指向子类对象，运行时表现的是子类特征。</li></ul><h3 id="abstract（抽象）"><a href="#abstract（抽象）" class="headerlink" title="abstract（抽象）"></a>abstract（抽象）</h3><ul><li>abstract 修饰类表示抽象类。</li><li>抽象类除了不能实例化对象之外，类的其它功能依然存在，成员变量、成员方法和构造方法的访问方式和普通类一样。</li><li>由于抽象类不能实例化对象，所以抽象类必须被继承，才能被使用。</li><li>abstract 修饰方法表示该方法为抽象方法，抽象方法没有方法体，具体由子类实现。</li><li>abstract 不能修饰成员属性。</li><li>abstract 不能和 private、final 和 static 修饰符一起使用。</li><li>abstract 修饰的方法必须被重写，private 修饰的方法为私有方法，私有方法是不能被重写，所以二者冲突。</li><li>抽象方法没有方法体，静态方法需要对方法体中的执行内容分配空间，所以不能和 static 共存。</li><li>final 修饰的类和方法不能被继承和重写，所以不能和 final 共存。</li></ul><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><ul><li>接口是一个抽象类型，是抽象方法的集合，接口通常以 interface 来声明。</li><li>接口没有构造方法。</li><li>接口定义的成员默认访问权限时 public。</li><li>接口不可以实现方法，接口中的方法会被隐式的指定为 public abstract。</li><li>接口中的变量会被隐式的指定为 public static final 变量。</li><li>接口中不能含有静态代码块以及静态方法(用 static 修饰的方法)。</li><li>普通类 extends 和 implements 可以配合使用，类只能继承一个类，但类可以实现多个接口。</li><li>接口可以继承多个接口，而类只能继承一个父类。</li><li>除非实现接口的类是抽象类，否则该类要实现接口中的所有方法。</li></ul><h4 id="抽象类和接口的区别"><a href="#抽象类和接口的区别" class="headerlink" title="抽象类和接口的区别"></a>抽象类和接口的区别</h4><ul><li>相同点都不能被实例化。</li><li>不同点：<ol><li>抽象类是有构造方法，而接口中是没有构造方法。</li><li>抽象类可以包含普通方法和抽象方法，而接口只能包含抽象方法。</li><li>接口中成员变量默认属性是public static final，而抽象类是默认权限（和普通类一样）。</li><li>接口中成员方法默认属性是 public abstract，而抽象类则是默认权限。</li><li>一个类只能继承一个抽象类，而一个类却可以实现多个接口。</li><li>抽象类是一个类，而接口并不是类，编写接口的方式和类相似。</li></ol></li></ul><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><ul><li>泛型即参数化类型，参数化类型就是将类型由原来的具体的类型参数化，然后在使用时传入具体的类型。</li><li>泛型可以使用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。</li><li>在编译过程中，正确检验泛型结果后，会将泛型的相关信息擦出。</li><li>并且在对象进入和离开方法的边界处添加类型检查和类型转换的方法，泛型信息不会进入到运行时阶段。</li><li>泛型解决了类型转换（不用手动强制类型转换）和类型检测（类型约束）的问题。</li></ul><h3 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 类名称&lt;泛型标识：可以随便写任意标识号，标识指定的泛型的类型&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> 泛型标识 <span class="keyword">var</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h3><h3 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h3><p>自定义泛型方法，单独给一个方法定义泛型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(T a)</span></span>&#123; &#125;</span><br></pre></td></tr></table></figure><ul><li>方法想要单独使用泛型，必须要有参数才有意义。</li></ul><p>静态方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">test</span><span class="params">(T a)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="泛型通配符"><a href="#泛型通配符" class="headerlink" title="泛型通配符"></a>泛型通配符</h3><p>泛型通配符 &lt;?&gt;：不知道使用什么类型来接收的时候可以使用?表示未知，通配符只用来做接收数据，不能用来操作数据。</p><h3 id="泛型的擦除"><a href="#泛型的擦除" class="headerlink" title="泛型的擦除"></a>泛型的擦除</h3><p>其中list_b就没有泛型了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list_a = <span class="keyword">null</span>;</span><br><span class="line">List  list_b = <span class="keyword">null</span>;</span><br><span class="line">list_b = list_a;</span><br></pre></td></tr></table></figure><h3 id="泛型注意点"><a href="#泛型注意点" class="headerlink" title="泛型注意点"></a>泛型注意点</h3><p>泛型前后类型必须保持一致。</p><p>从 JAVA7 开始后面的类型可以不声明泛型如：<code>new ArrayList&lt;&gt;();</code></p><p>泛型是没有继承的。</p><p>泛型其实是一个语法糖，本质还是Object，内部其实还是要做强转的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">	T  x;</span><br><span class="line">	T  y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 本质还是</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span></span>&#123;</span><br><span class="line">	Object  x;</span><br><span class="line">	Object  y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>泛型不能使用在静态方法上面。原因：静态方法是直接使用类名调用，泛型是在创建对象的时候才会去声明。</p><p>泛型只能指定声明包装类，不能是基本数据类型， 所以泛型是引用类型，引用类型就支持继承。</p><h2 id="匿名对象"><a href="#匿名对象" class="headerlink" title="匿名对象"></a>匿名对象</h2><p>定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> 类名().属性 = 参数;</span><br></pre></td></tr></table></figure><p>匿名对象指没有名称的对象，创建对象之后没有赋给某一个变量。</p><p>因为没有名称，匿名对象仅仅只能使用一次，一般的，把匿名对象作为方法的实参传递。</p><h2 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h2><p>自动装箱：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer num = <span class="number">10</span>;</span><br><span class="line"><span class="comment">// 相当于		</span></span><br><span class="line">Integer num = Integer.valueOf(<span class="number">10</span>);</span><br></pre></td></tr></table></figure><ul><li>其实是一个语法糖。</li><li>valueOf 方法当中的实现还是new一个包装类。</li></ul><p>自动拆箱：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n = num; 其中num为Integer类型</span><br><span class="line"><span class="comment">// 相当于</span></span><br><span class="line"><span class="keyword">int</span> n = num.intValue;</span><br></pre></td></tr></table></figure><h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><p>外部类只能有两个修饰符，public 和默认（什么都不写）。</p><h3 id="实例内部类"><a href="#实例内部类" class="headerlink" title="实例内部类"></a>实例内部类</h3><p>创建内部类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outter</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>        <span class="comment">// Inner的引用，this指针与对象有关系，不关类的事。</span></span><br><span class="line">        Outter.<span class="keyword">this</span>	<span class="comment">// Outter的引用。</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>实例内部类可以理解为外部类的一个成员属性。</li><li>实例内部类中的<strong>成员</strong>不能用 static 修饰。因为 static 只能在外部类或静态内部类中声明。</li><li>实例内部类可以访问外部类的静态成员和普通成员。</li></ul><h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><p>静态内部类没有外部类的引用，因为外部类在堆中开辟内存，静态内部类在方法区开辟内存。</p><p>静态内部类只能访问外部类的静态成员。</p><p>静态内部类中可以用 static 修饰。</p><h3 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h3><p>局部内部类定义在类中的方法中，不能有 static 修饰，因为用 static 修饰，表示依赖与类。局部内部类存在与类中的方法，所以不能在外部类中创建。<br>局部内部类访问当前方法中的变量，必须用final修饰，普通变量和方法存在与栈中，而实例化对象存在与堆中。当方法出栈，局部内部类访问的变量跟着一起出栈就访问不到，造成空指针异常，用final修饰就是把变量存放在方法区中。<br>匿名内部类。必须有父类 或 接口 才能实现。<br>创建方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">new 父类构造器  或  接口()&#123;</span><br><span class="line"></span><br><span class="line">	定义方法</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法中的内部类访问外部类方法必须定义final关键字。方法是处于栈中的，生命周期比较短。</p><h1 id="String"><a href="#String" class="headerlink" title="String"></a>String</h1><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><ol><li>String.format();</li></ol><h1 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h1><p>生成随机数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Random r = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取0-9之间的随机数</span></span><br><span class="line"><span class="keyword">int</span> number = r.nextInt(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取1-10之间的随机数</span></span><br><span class="line"><span class="keyword">int</span> num = r.nextInt(<span class="number">10</span>)+<span class="number">1</span>;</span><br></pre></td></tr></table></figure><h1 id="时间戳"><a href="#时间戳" class="headerlink" title="时间戳"></a>时间戳</h1><h2 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h2><p>时间戳是指格林威治时间 1970 年 01 月 01 日 00 时 00 分 00 秒(北京时间 1970 年 01 月 01 日 08 时 00 分 00 秒)起至现在的总<strong>秒</strong>数。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>获取毫秒级时间戳：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法 一  </span></span><br><span class="line">System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法 二  </span></span><br><span class="line">Calendar.getInstance().getTimeInMillis();</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法 三  </span></span><br><span class="line"><span class="keyword">new</span> Date().getTime();</span><br></pre></td></tr></table></figure><ul><li>System.currentTimeMillis() 方式速度最快。</li><li>Calendar.getInstance().getTimeInMillis() 方式速度最慢，Canlendar 因为要处理时区问题会耗费很多的时间。</li></ul><p>获取纳秒级时间戳：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.nanoTime();</span><br></pre></td></tr></table></figure><h1 id="UUID"><a href="#UUID" class="headerlink" title="UUID"></a>UUID</h1><h2 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h2><p>UUID 目的是让分布式系统中的所有元素，都能有唯一的辨识信息，而不需要通过中央控制端来做辨识信息的指定。</p><p>UUID 是由一组 32 位数的 16 进制数字所构成，所以 UUID 理论上的总数为 16^32=2^128，约等于 3.4 x 10^38。也就是说若每纳秒产生 1 兆个 UUID，要花 100 亿年才会将所有 UUID 用完。</p><p>UUID 的标准型式包含 32 个 16 进制数字，以连字号分为五段，形式为 8-4-4-4-12 的 32 个字符。示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">550e8400-e29b-41d4-a716-446655440000</span><br></pre></td></tr></table></figure><p>UUID由以下几部分的组合：</p><ol><li>当前日期和时间。</li><li>时钟序列。</li><li>全局唯一的IEEE机器识别号，如果有网卡，从网卡MAC地址获得，没有网卡以其他方式获得。</li><li>在 hibernate（Java orm框架）中， 采用 IP-JVM 启动时间 - 当前时间右移32位 - 当前时间 - 内部计数（8-8-4-8-4）来组成 UUID。</li></ol><h2 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h2><p>生成 UUID：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String uuid = UUID.randomUUID().toString().replace(<span class="string">"-"</span>, <span class="string">""</span>).toLowerCase();</span><br></pre></td></tr></table></figure><h1 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h1><p>常量可以通过一个外部文件记录，JAVA 程序通过读取这个文件读取常量（比如 URL、参数）。</p><p>当常量改变的时候，就可以通过修改静态文件改变常量，就不用改程序代码。</p><h1 id="JAVA-三层架构"><a href="#JAVA-三层架构" class="headerlink" title="JAVA 三层架构"></a>JAVA 三层架构</h1><p>三层：controller、service、dao。</p><img src="https://ftp.bmp.ovh/imgs/2019/08/463b74f379e33155.png" width="50%"><h1 id="MVC-模式"><a href="#MVC-模式" class="headerlink" title="MVC 模式"></a>MVC 模式</h1><p>MVC 全名是 Model View Controller。</p><ul><li>Model 指的是数据（比如数据库保存的数据）。</li><li>Controller 控制器负责从视图读取数据，控制用户输入，并向模型发送数据（比如 JAVA 后端）。</li><li>View 指的是页面展示（前端）。</li></ul><p>MVC 分层有助于管理复杂的应用程序，因为您可以在一个时间内专门关注一个方面（前端、后端、数据库分离）。</p><ul><li>后端负责通过 jsp 渲染网页。</li><li>前端只负责调用后端接口和页面美化。</li></ul><hr><p>jvm内存<br>基本类型变量存放在栈中。<br>方法存放在栈中。<br>new关键字修饰存放在堆中。<br>static关键字修饰存放在方法区。<br>final关键字修饰存放在方法区。<br>字符常量存放在方法区中的常量池中。<br>枚举<br>关键字enum<br>定义枚举 enum 枚举名称{<br>常量对象1，常量对象2，常量对象3…<br>} 注意：枚举中的常量对象后面不需要跟加分号，如果要在枚举对象后面定义变量或方法，一定要加分号。<br>枚举中的常量默认被 public static final 枚举类型 修饰。<br>枚举内部私有化自己的构造器，不能创建对象。<br>枚举是一个特殊的java类，枚举类默认继承enum这个类。枚举是多个常量对象的集合。</p><p>System.out.println( 枚举名称.常量 ); 和 System.out.println( 枚举名称.常量.name ); 效果一样。</p><p>枚举名称.常量.ordinal() 返回枚举下标。<br>switch(枚举名称.常量){ //相当于 枚举名称.常量.ordinal();<br>case 枚举中常量1:break;<br>case 枚举中常量2:break;<br>}</p><p>valueOf( String s )把一个字符串转成一个枚举类型，字符串对应的枚举必须要存储，否则会报错。<br>枚举类型 新变量 = 枚举类型.valueOf(“枚举中的常量”);</p><p>values() 通过values可以获取数据当中的所有常量，返回枚举类型的数据。<br>枚举中定义的是枚举类型的对象，不是常量，而是常量对象。<br>String<br>String本质还是char类型数组。<br>String str = null; 还没有分配空间。<br>String str = “”; 已经分配了空间，但内容为空。<br>字符串比较：<br>== 比较两个字符串地址是否相等。<br>equals(Object obj); 在Object中和==号的作用相同，但String已经覆盖了Object类的方法，不仅比较地址是否相等，而且比较内容是否相等，如果地址相等，立即返回true，如果地址不等，继续比较内容是否相等，如果相等，返回true，否则返回false。</p><p>String str = “abc”;<br>String str = new String(“abc”);<br>上面两种写法的区别：<br>第一种写法：会先到常量池中看一下是否存在该字符串常量，如果存在，直接使用，不创建新的地址。否则，就会在常量池中创建一个对象。<br>第二种写法，先在堆中开辟一块空间，在查看常量池中是否存在”abc”这个对象，若存在，堆中的对象就会指向这个”abc”的对象，再赋值给str。</p><p>String str = “abc”;<br>String str1 = “a” + “b” + “c”;<br>str 和 str1 是否相等？<br>相等，编译时，编译器会把“a” + “b” + “c” 这种形式 弄成 “abc” 这种形式。<br>String temp = “ab”;<br>String str3 = temp + “c”;<br>str3 和 str是否相等？<br>不等，原因如下图</p><p>String类常用方法：<br>String(byte[] byte,int start,int length);<br>start为byte数组开始读的下标，length为要读多少个元素。该构造方法在读取文件的时候经常使用。<br>String(byte[] byte,int start,int length, String charsetName); charsetName 为编码类型。<br>int indexOf(String str);<br>返回子串str在当前字符串中的位置，若没有找到，返回-1。<br>String substring( int beginindex );<br>截取当前字符串从beginindex处的字符直到最后的子串。<br>String substring( int beginindex, int endindex );<br>截取当前字符串从beginindex处开始到endindex处的子串，不包括endindex处。<br>String trim()<br>作用是去掉字符串两端的多余的空格，且无论两端的空格有多少个都会去掉，当然中间的那些空格不会被去掉。</p><p>字符串连接：<br>“+”除字符串相加功能外，还能将字符串与其他的数据类型相连成一个新的字符串。</p><p>String是不可变字符串，当进行字符串拼接的时候，会不断创建对象<br>可变字符串：StringBuilder 效率最高，但是没有加锁，不安全<br>StringBuffer 效率比StringBuilder慢一些，但是安全<br>可变字符串，它的内容可以进行修改，改变是不会创建新的地址。<br>可变字符串通过append(String str); 方法进行拼接。</p><p>字符串包含双引号：通过转义字符 \” 转义成 “<br>集合类<br>数组可以存放任意类型，如基本数据类型和引用类型。<br>而集合类只能存放引用类型，就算存放基本数据类型，也会自动装箱。</p><p>Collection：<br>size(); 获取集合中的长度。<br>toArray(); 将集合放回Object类型的数组。<br>addAll(Collection c); 将c集合所有内容合并到指定类中。如b.addAll(c);<br>remove(“删除指定值”);</p><p>Iterator是一个接口，具体实现是各种集合类中完成。<br>Iterator it = c.iterator(); 将c集合中的内容放到迭代器中，放到迭代器中的内容会自动类型提升，提升为Object类型。<br>it.next(); 获取迭代器中的内容，类型为Object类型的引用。<br>it.hasNext(); 判断迭代器中是否还有内容，如果有返回true，否则返回false。<br>it.remove(); 删除迭代器正在遍历的元素。不能直接修改集合中的结果，一定要通过迭代器的remove方法修改。原因通过具体源码可得。</p><p>list：<br>add(index, “填充参数”); 根据角标填充参数，注意不能大于list的长度。<br>get(index); 根据角标获取参数。<br>listIterator(); 返回ListIterator类型的迭代器，功能比普通迭代器强大，有add()方法。ListIterator也是一个接口，具体实现在集合类中完成。</p><p>ArrayList：<br>实现原理：把原有数据复制出来，再创建一个新数组，容量扩充原来的50%，在原数据放进去。<br>获取元素比较快。<br>Vector:<br>和ArrayList差不多，但是Vector比ArrayList跟安全，因为加锁了。<br>LinkedList：<br>增加删除操作比较快。</p><p>Set：<br>想要在Set当中自定义对象去重，必须覆盖equals和hashCode方法。Set集合先判断hashCode是否相等，若果两个对象的hashCode相等，就通过类中equals方法比较。</p><p>LinkHashSet:<br>LinkHashSet是HashSet的子类，它存放数据是有序的，而HashSet存放数据无须的，它们都不能存放相同数据。<br>TreeSet<br>用来对数据进行排序。向这个集合中存放数据都是排序好，不重复的。<br>TreeSet存放的引用类型必须相同。因为引用类型不同，无法比较，也就无法存放。<br>要将自定义对象存放到TreeSet集合中，必须实现Comparable接口中的comparaTo方法。<br>comparaTo返回值等于0，表示比较的值相等。<br>comparator返回值小于0，表示比比较值小。<br>comparator返回值大于0，表示比比较值大。<br>TreeSet可以构造方法中可以传入一个比较器，根据比较器中的规则进行比较。<br>要使用比较器必须实现ComparaTor接口中的compara()方法。<br>Map：<br>map包含两个集合，一个Set集合，一个Collection集合。<br>put(key, value); 将键值对存放到map集合中。如果key值不重复，返回null。如果重复，就把原来覆盖掉，把原来的key值作为返回值。<br>map不能使用foreach进行遍历。<br>get(key); 根据key值取出对应value值。<br>keySet() 将key集合返回为一个Set集合，通过这个set集合可以获取所有key值，通过key值就可以拿出value值。<br>entrySet() 将map集合中的内容转成entry对象返回entry对象的Set集合。entry为map集合中的内部接口。<br>foreach( Map.Entry&lt;K, V&gt; entry : map.entrySet() ){<br>entry.getKey();<br>entry.getValue();<br>} containsKey(“key”) 判断key值是否存在，存在返回true，否则返回false<br>LinkHashMap和HashMap唯一区别是，LinkHashMap存放数据是有序的，而HashMap存放数据是无序的。<br>TreeMap是对key值进行排序。<br>异常<br>异常处理机制由捕获异常和处理异常两部分。当出现了异常事件，就会生成一个异常对象，传递给运行中的系统。系统将会寻找处理异常的方法，把当前对象交给该方法处理。如果没有找到可以捕获异常的方法，系统将会终止。<br>在try代码块中出现异常，会终止try代码块中后续程序，try代码块外的代码不会受到影响。<br>Exception：<br>getMessage(); 获取异常信息。<br>直接打印异常对象 获取异常类型和信息。<br>printStackTrace(); 获取异常类型、信息和发生代码错误的位置。</p><p>throw： 抛出运行时异常。如：throw new RuntimeException(“非法数据”);<br>为什么抛出运行时异常，可以不用处理。异常可以往上抛，可以抛给jvm处理，jvm内部有异常处理机制。<br>抛出编译时异常。如 throw new Exception(“非法数据”); 抛出编译时异常，要么必须处理，要么往上抛出异常。<br>throw后面跟异常对象的名称。<br>throws 用在方法声明之后，后面可以跟多个异常类型的引用。<br>return阻止当前方法运行， 是不能阻止finally代码块的运行。finally代码块外的代码不会执行。<br>自定义异常：<br>定义运行时异常：继承运行时异常RuntimeException。<br>定义编译时异常：继承Exception类。<br>定义有参数的异常类：定义带参数的构造方法，构造方法中把参数传入父类的构造方法。通过super关键字。<br>通过类加载器获得文件绝对路径<br>xxx.class.getClassLoader().getResource(“”).getPath();<br>获取src资源文件编译后的路径(即classes路径)。</p><p>xxx.class.getClassLoader().getResource(“文件”).getPath();<br>获取classes路径下“文件”的路径，如果文件不存在则会抛出异常。</p><p>xxx.class.getResource(“”).getPath();<br>getResource(“”)，获取类所在包的路径。<br>getResource(“/”) ，java 2e 获取classes目录的根目录， java se 获取bin目录的根目录。</p><p>this.getClass().getClassLoader().getResource(“”).getPath();<br>通过类的实例获取路径。<br>file类的使用<br>定义File类：<br>File file = new File(String pathname);<br>pathname为文件的路径名称。<br>File file = new File(String pathname, String child);<br>pathname为路径名，child为文件名。<br>File file = new File(File parent, String child);<br>parent为File类，表示所在目录的路径， child为文件名， 其中parent的实例为new File(“C:/目录路径”);<br>file类的路径可以是目录路径或文件路径。<br>常用方法：<br>boolean mkdir(); 创建目录。<br>boolean mkdirs(); 创建多层目录。<br>boolean createNewFile();<br>如果文件不存在，创建一个空的文件。创建文件的所在目录必须存在，不然报错。<br>boolean exists(); 判断文件是否存在。<br>String getName(); 取得文件名或路径名。<br>String getParent(); 取得上一级目录。<br>boolean delete(); 删除文件。假如要删除目录，该目录必须为空。<br>String[] List(); 返回当前目录下的所有文件和子目录。<br>不常用方法：<br>long length(); 获取文件的大小，以字节为单位。<br>boolean isDirectory(); 判断是否为目录，文件必须存在才能判断。<br>boolean isFile(); 判断是否为文件，文件必须存在才能判断。</p><p>File类的对象主要用于建立与某磁盘文件的链接，获取主要信息，例如文件所在目录，文件长度，文件的读写权限。不涉及对文件的读写操作。<br>输入输出流不能同时操作同一个文件。<br>输入/输出流 的 使用<br>流中的数据可以是未经加工的二进制流数据，也可以是经一定编码处理后符合某种格式规定的特定数据。<br>字节流是最基本的，采用ASCII编码,所有的InputStream和OutputStream的子类都是,主要用在处理二进制数据，它是按字节来处理的。<br>但实际中很多的数据是文本，又提出了字符流的概念，采用Unicode编码.它是按虚拟机的encode来处理，也就是要进行字符集的转化。<br>所有输入流类都是InputStream抽象类或Reader抽象类的子类，而所有输出类都是OutputStream抽象列或Writer抽象类的子类。</p><p>InputStream:<br>int read(byte[] b);<br>从输入数据流中读取字节并存入数组中。<br>int read(byte[] b, int off, int len);<br>从输入数据流中读取len个字节存入数组下标为off的数组b中。<br>void close();<br>关闭输入数据流。<br>OutputStream:<br>void write(byte[] b, int off, int len);<br>当文件不存在会自动创建文件。<br>void close();<br>先关闭输出流再关闭输入流。<br>需要自己close的东西，一般都是用了虚拟机之外的资源，例如端口，显存，文件等，虚拟机无法通过垃圾回收释放这些资源，只能你显式调用close方法来释放。你读一个文件，忘记关闭了流，你在操作系统里对这个文件的写，删除等操作就会报错，告诉你这个文件被某个进程占用。</p><p>FileOutputStream(File file);<br>FileInputStream(File file);</p><p>BufferedInputStream 是缓冲输入流。它继承于FilterInputStream。<br>BufferedInputStream(InputStream in);<br>内置缓存字节数组的大小 8KB。<br>BufferedInputStream(InputStream in, int size);<br>使用指定buf大小。<br>1.BufferedOutputStream在close()时会自动flush。<br>2.BufferedOutputStream在不调用close()的情况下，缓冲区不满，又需要把缓冲区的内容写入到文件或通过网络发送到别的机器时，才需要调用flush。<br>BufferedInputStream装饰一个 InputStream 使之具有缓冲功能。</p><p>DataInputStream(InputStream is);<br>DataOutputStream(OutputStream os);<br>这个输入输出流可以按照数据类型来读取数据。<br>RandomAccessFile类<br>RandomAccessFile类负责对一部分的文件输入 / 输出。 它不是InputStream类和OutputStream类的类。RandomAccessFile类创建的流可以读取文件的数据也可以向文件写入数据。不用创建同时创建输入输出类。</p><p>RandomAccessFile类的创建：<br>RandomAccessFile(String path, String mode);<br>RandomAccessFile(File file, String mode);<br>mode的参数分为 r, rw, rws, rwd<br>r : 表示只读，试图进行写操作将引发异常。<br>rw : 表示可读可写， 文件不存在将会先创建文件。<br>rws : 表示可读可写，并且更改文件内容或元数据时同步写到存储设备中。<br>rwd : 更改文件内容时同步写到存储设备中。</p><p>常用方法：<br>long getFilePointer(); 返回文件指针的当前位置。<br>void seek(long pos);<br>设置文件指针到给定的绝对位置。一般以位置0标志文件的开始。<br>long length(); 返回文件的长度。<br>close(); 关闭文件。<br>readDouble() 从文件中读取一个双精度浮点值（8字节）<br>多线程<br>创建多线程有两种方法：继承Thread类和实现Runnable接口。</p><p>通过继承Thread类来创建线程类：<br>一个Thread类的实例对象就是一个线程，Thread类的子类对象也是一个线程。<br>线程在程序执行时的代码被封装在Thread类或及其子类的成员方法中。通过覆写run()方法来完成所需要的功能。<br>线程的启动或运行并不是调用成员方法run(),而是调用成员方法start()达到间接调用run()方法的目的。</p><p>通过实现Runnable接口来创建线程类：<br>Runnable只有run() 方法, 没有start() 方法。Runnable接口实现类的实例只是具有线程体的目标对象。<br>启动 Runnable接口实现类的 线程必须将类的实例传递给Thread类 的构造器。创建出Thread类的实例。通过Thread类的引用调用start() 方法。<br>Runable接口 只是一个接口。 没有任何方法。<br>注意：必须覆盖 Thread类 或 Runnable 接口 的 run() 方法 才能定义线程完成所需功能。</p><p>多线程是多个线程之间轮流执行的,就是将一个时间段分成若干个时间片,每个线程只运行一个时间片。时间片结束，运行下一个相乘。例如一个 线程 在 死循环中， 它的时间片已过。也会被剥夺 cpu 的控制权。</p><p>main方法本身也是一个线程。</p><p>线程5种状态：<br>新生态：已经被创建，但没有分配CPU资源。<br>可运行状态：线程执行start()方法后，便进入可运行状态。此时线程不一定立即执行。但CPU随时可能被分配该线程。<br>运行状态：正在运行的线程处于运行状态。此时线程独占CPU的控制权。若有更高优先级的线程出现，则该线程将放弃控制权进入可运行状态。<br>阻塞状态：如果线程处于阻塞状态，此时线程不会被分配CPU时间。<br>死亡状态：当线程结束后进入死亡状态。</p><p>synchronized关键字：<br>synchronized 块的使用：<br>Object obj<br>synchronized (obj) {<br>//代码块<br>} 要执行代码块中的内容，必须争夺obj上的锁。</p><p>简化写法：<br>synchronized ( this ) {<br>//代码块<br>} 要执行代码块中的内容，必须争夺这个对象的锁。</p><p>synchronized 方法加锁。 本质还是对 this 加锁。</p><p>对静态方法的同步本质上是对类的同步。对类 的 .class 加锁</p><p>对象锁是在一个类的对象上加的的锁，只有一把，不管有几个方法进行了同步。这些同步方法都共有一把锁，只要一个线程获得了这个对象锁，其他的线程就不能访问该对象的任何一个同步方法。</p><p>常用方法：<br>static int activeCount(); 查看线程数。<br>static void sleep(long millis);<br>在指定的时间内处于阻塞状态，指定时间一过，线程进入可执行状态。<br>sleep()方法导致了程序暂停执行指定的时间，让出cpu给其他线程。在调用sleep()方法的过程中，线程不会释放对象锁。<br>millis单位为毫秒。<br>static void yield();<br>使处于运行状态的线程主动抛弃CPU控制权，进入可运行状态。<br>final void wait();<br>让线程处于阻塞状态，并让对象释放锁。当其他线程类对象调用notify() 方法是。 阻塞状态的线程从 wait() 代码处继续往下执行。 不会重新进入方法体。<br>final void notify();<br>唤醒阻塞状态的任意一个线程（只要是Thread的子类调用wait()方法都能用notify() 方法唤醒）。与wait()方法配套使用。<br>final void notifyAll(); 唤醒所有阻塞状态的线程。<br>static Thread Thread.currentThread(); 可以获取当前线程的引用。</p><p>wait()方法和notify()要执行这两个方法，前提线程必须获得其对象的锁，所以这两个方法必须在同步块（synchronized 块）代码里面调用。而且这两个方法定义在Object对象中。</p><p>线程优先级：Java线程优先级以整数1-10表示。最大优先级为10，最小优先级为1。默认优先级为5。<br>同过Thread 类 的getPriority(); 方法获得线程 的优先级。 setPriority(); 设置优先级。<br>jdbc编程<br>ddl数据定义语言<br>dml数据操纵语言<br>dql数据查询语言<br>executeUpdate(String) 执行ddl和dml语句，返回整数。ddl返回0，dml返回更新数据的行数。<br>executeQuery(String) 执行dql语句，返回结果集。<br>Statement接口：<br>对于dql返回查询的结果集。<br>对于dml返回受影响的函数。<br>对于ddl返回0</p><p>ResultSet接口：<br>若列的类型是varchar, char, text 都使用getString来获取列。<br>若列的类型是int, integer 使用getInt来获取列。</p><p>PreparedStatement接口：<br>查看预编译sql语句：<br>((JDBC4PreparedStatement)ps).asSql(); 返回的是sql语句，可以直接打印。<br>ps为PreparedStatement类的对象。<br>PreparedStatement是Statement的子类。<br>Mysql没有预编译池。而Oracle有预编译池。所以PreparedStatement和Statement在MySQL上性能几乎一样。而在Oracle上PreparedStatement类会比Statement类性能上更有优势。</p><p>调用MySQL存储过程:<br>con.prepareCall(“ { call 存储过程名(?) } ”);<br>con为连接对象。<br>?为传入参数。<br>返回值为CallableStatement类。</p><p>获得存储过程输出参数：<br>CallablesStatement cs = con.prepareCall(“ { call 存储过程名(?, ?) } ”);<br>cs.setXxx(1, 参数);<br>cs.registerOutParameter(2, Types.数据库类型);<br>cs.execute;<br>Xxx name = cs.getXxx(2);</p><p>连接对象close方法并不是释放对象内存，而是断开数据库连接。</p><p>常见连接池：dbcp连接池、c3p0连接池（07年已经没有维护了）<br>、druid连接池（阿里巴巴提供的连接池，性能好）。</p><p>配置连接池的读取文件：<br>后缀名必须是properties，内容以key=value的形式编写。<br>java代码：<br>Properties p = new Properties();<br>FileInputStream in = new FileInputStream(“文件路径”);<br>p.load(in);<br>String value = p.getProperty(“key”);<br>dbcp读取配置文件（注意key值不能乱写,一定要指定以下key值）：<br>driverClassName<br>url<br>username<br>password</p><p>Properties p = new Properties();<br>FileInputStream in = new FileInputStream(“文件路径”);<br>p.load(in);<br>DataSource ds = BasicDataSourceFactory.createDataSource(p);</p><p>dml代码抽取：<br>PreparedStatement中SetObject(index, 参数)，其中可以接收任意参数;<br>Java反射<br>Class.forName(xxx.xx.xx)返回的是一个Class 类。Class类对象表示的是一个 类 或 接口。<br>Class.forName(String className)这个方法传入一个类的权限定名称。然后再用这个Class类型的实例调用newInstance()方法会返回一个 传入类型 的对象。<br>每个Java类必须由某个类加载器装入到内存。Class.forName(xxx.xx.xx)的作用是要求JVM查找并加载指定的类，也就是说JVM会执行该类的静态代码段。</p><p>Java反射中调用getClass()方法返回的是这个类的类对象。Java中每一个类在被编译成为.class文件的时候，JVM（Java虚拟机）都将会自动对每一个类创建一个类对象，这个类对象包含了这个类的所有的信息（包括成员变量、方法、构造器）。今后我们在创建这个类的实例或者这个类的对象时都是以这个类的类对象为蓝图（或模板）来构建的。</p><p>如果该类没有构造方法，newInstance() 就会抛出异常。 例如 实现接口的匿名内部类。<br>Socket编程<br>任何语言中都有Socket编程，本质还是 bin + ip + 端口通讯的模式， 所以就算是 c 语言编写的服务器， java 编写的客户端 都可以互通。<br>Java.net包中包含 客户端 Socket 类 和 ServerSocket 类。</p><p>Socket类：<br>Socket(String host, int port); host是服务器IP地址，port是访问服务器的端口号。<br>getInputStream(); 获得输入流。<br>getOutputStream(); 获得输出流。<br>getInetAddress(); 获取客户端ip地址。<br>close() 断开接收端连接。</p><p>ServerSocket类：<br>ServerSocket (int port); 设置服务器端口号。<br>Socket accept();<br>等待接收端的连接请求，如果客户端不发送连接请求，将一直等待。返回Socket类的对象实例，通过Socket类可以获得客户端发送来的输出流。这样就可以解析客户端发送的数据。</p><p>InetAddress类：<br>static InetAddress getByName(String host); 通过域名， 获得InetAddress类。<br>static InetAddress getLocalHost() 获取本机IP地址。<br>String getHostName(); 获取InetAddress对象所含域名。<br>String getHostAddress(); 获取InetAddress对象所含的IP地址。</p><p>DatagramPacket类（用于UDP）：<br>DatagramPacket(byte data[], int length, InetAddress address, int port);<br>参数data用于存放数据包数据， length为数据包中数据的长度， address表示发送数据的目的地址。port表示发送数据的端口号。<br>DatagramPacket(byte data[], int offset ,int length, InetAddress address, int port);<br>offset表示从 offset 下标开始读取 length 长度数组。<br>DatagramPacket(byte data[], int length);<br>该构造函数用于新建一个数据包对象用于接收数据包。<br>synchronized InetAddress getAddress();<br>返回一个InetAddress类的实例，用于获取数据包中的信息。</p><p>DatagramSocket类：<br>DatagramSocket(); 该对象负责发送数据包。<br>DatagramSocket(int port);<br>port必须和数据包中的端口号相同。也就是服务器端口号。<br>void send(DatagramPacket p) ; 发送指定数据包。<br>synchronized void receive(DatagramPacket p);<br>服务器端接收数据，p为存储数据的数据包。<br>void close(); 断开连接。<br>数据包中的主要信息主要是通过byte[] 数组存储。<br>Servlet编程<br>servlet 是服务器 上的 一个程序， 负责处理 服务器接收的 http 请求。</p><p>response.setContentType(“text/html;charset=UTF-8”);<br>response.setContentType(MIME)方法设置发送到客户端的响应的内容类型，此时响应还没有提交。给出的内容类型可以包括字符编码说明，例如：text/html;charset=UTF-8<br>如果该方法在getWriter()方法被调用之前调用，那么响应的字符编码将仅从给出的内容类型中设置。该方法如果在getWriter()方法被调用之后或者在被提交之后调用，将不会设置响应的字符编码。</p><p>PrintWriter out = response.getWriter();<br>获取输出流 输出的对象是页面，getWriter的返回值是一个PrintWriter类型，所以用PrintWriter out对象来接受。</p><p>String str = “任意字符串”;<br>str = new String(str.getBytes(“gbk”),”utf-8”);</p><p>备注说明：<br>str.getBytes(“ISO8859-1”); 意思是以ISO8859-1的编码重新编码成二进制位。<br>new String(XXX,”UTF-8”); 意思是以UTF-8的解码生成字符串。</p><p>URl参数中?和&amp;的区别<br>?后面带的是get方式传递的值,如果有多个值,用&amp;号分割。</p><p>编码和解码的概念：<br>从文字到0、1的映射称为编码，反过来从0、1到文字叫解码。</p><p>request.getParameter(“xxx”)的参数的取值<br>1.Html中form表单中标签的name属性<br>2.Html中form表单提交时的action的参数<br>3.Html中url的内容</p><p>servlet标签中<br>servlet-name：servlet类名<br>servlet-class：servlet类所在路径</p><p>servlet-mapping标签中<br>servlet-name：servlet类名（同上）<br>url-pattern：访问此路径文件时候使用转到上面配置的servlet上</p><p>&quot;这个是转义字符，用来表示双引号【”】，因为在java中两个双引号之间的部分表示为字符串。</p><p>hasMoreElements()<br>测试此枚举是否包含更多的元素。<br>返回：当且仅当此枚举对象至少还包含一个可提供的元素时，才返回 true；否则返回 false。</p><p>nextElement( )<br>如果此枚举对象至少还有一个可提供的元素，则返回此枚举的下一个元素。</p><p>Servlet中request.getParameter和getParameterValues getParameterNames三者区别<br>1.request.getParameter:获取前台表单单个元素name对应的value值<br>2.request.getParameterValues:获取前台表单多个标签同名name对应的所有value值<br>3.request.getParameterNames:获取前台表单所有标签元素name的对应的所有value值</p><p>子类属性方法多，所以可以直接赋值给父类，而父类属性方法少，不能将子类的所有属性和方法覆盖。</p><p>response.setIntHeader(“Refresh”, 5); //设置刷新自动加载时间为 5 秒<br>ate date = calendar.getTime(); // 从一个 Calendar 对象中获取 Date 对象<br>SimpleDateFormat sdf=new SimpleDateFormat(“yyyy-MM-dd HH:mm:ss”);<br>或：<br>SimpleDateFormat sdf=new SimpleDateFormat();<br>sdf.applyPattern(“yyyy-MM-dd HH:mm:ss”); 设置日期输出的格式</p><p>sdf.format(Date date); 是将当前时间格式转换为指定格式</p><p>————————————————-bean的生命周期——————————————-<br>init-method属性配置初始化方法，初始化方法用于准备数据。<br>destroy-mothod属性用于配置销毁方法<br>容器close并且bean作用域为单例（singleton），销毁方法才会执行。<br>——————————————-Cookies—————————————————–<br>Cookie cookie = new Cookie(“admin”, “identification”); 创建cookies对象<br>cookie.setMaxAge(60/<em>秒</em>/ * 20); 设置生命周期<br>response.addCookie(cookie); 响应流添加cookies<br>Cookie[] cookies = response.getCookies(); 响应流获得所有cookies，并返回cookies数组<br>cookie.getName() 获得cookie的name值<br>cookie.getValue() 获得cookie的value值<br>cookie不设置生命周期，默认存储到浏览器的内存中，当浏览器关闭，cookie自动销毁。<br>cookie的携带路径：默认情况下会在访问创建cookie的web资源相同的路径都携带cookie信息。<br>cookie.setPath(“/CookiePro/cookieServlet”); 只有访问cookie.Servlet才携带cookie信息<br>cookie.setPath(“/CookiePro”); 访问指定的工程（项目）时，都会携带cookie信息。<br>cookie.setPath(“/”); 访问服务器部署的所有工程时都会携带cookie信息<br>————————————Session————————————————–<br>Session技术是将数据存取在服务器的技术，会为每个客户都创建一块内存空间存储客户的数据。Session需要借助于cookie存储客户的唯一性标识sessionid来找到自己的session域。</p><p>HttpSession session = request.getSession();<br>根据sessionid判断该客户是否在服务器已经存在session域，若存在获取专属于当前会话的session对象，若不存在，会创建一个新的session放回。</p><p>session.getAttribute(“name”, “value”); 向session域写数据。<br>session.getAttribute(“name”); 通过name值获取value。</p><p><session-config>web.xml配置过期时间。<br><session-timeout>30</session-timeout><br></session-config></p><p>session域是从第一次执行request.session时创建。session过期时间是从最后一次操作结束开始计算。相当于没有执行request.session。</p><p>session.invalate 手动销毁session。<br>浏览器关闭，session并没有销毁，销毁的是以cookie形式存储的sessionid，没有设置生命周期，默认存储在浏览器中。<br>设置sessionid的生命周期，就是模拟sessionid的cookie。<br>session.getId(); 获取sessionid。</p><p>—————————————————-请求的发送方式———————————<br>1.通过浏览器的地址栏<br>2.通过html当中的form表单<br>3.通过a标签的href属性<br>4.src属性<br>——————–GET请求和POST请求————————————-<br>get请求：<br>大小限制：请求字符串中最多只能有1024个字节<br>编码类型为application/x-www-form-urlencoded。<br>只允许ascii字符类型，不能用二进制流。<br>查询字符串会显示在地址栏的url中，不安全。<br>get请求主要用于获取数据。</p><p>post请求：<br>编码类型没有限制。<br>参数类型没有限制，可以是字符串可以是二进制流。<br>post传输数据量大，可以达到2m。<br>post为了将数据传送到服务器。</p><p>get请求会发送一个数据包，post发送两个数据包。<br>post方式参数存放在请求数据包的消息体中。 get方式参数存放在请求数据包的请求行的URI字段中,以?开始以param=value&amp;me2=value2的形式附加在URI字段之后。而request.setCharacterEncoding(charset);只对消息体中的数据起作用,对于URI字段中的参数不起作用。get用new String(target.trim().getBytes(“ISO-8859-1”), charset);。</p><p>当文件比较大的时候可以考虑分段上传方式。<br>———————————–HTTP协议版本—————————————————<br>http1.0，发送请求，创建一次连接，获得一个web资源，断开连接。<br>http1.1，发送请求，创建一次连接，获得多个web资源，保持连接。<br>———————————优化tomcat启动速度————————————-<br><absolute-ordering>一个jar包都不扫描，servlet3.0才能添加这个标签<br>—————————servlet生命周期————————————————<br>当客户端向服务器发送请求，服务器读取xml文件，找到设置的url再找到权限名，通过java放射创建对象。<br>一般当服务器关闭的时候调用destroy方法<br><load-on-startup>2</load-on-startup>服务器启动调用init方法，其中数据是优先级。<br>Servlet容器默认是采用单实例多线程的方式处理多个请求的，所以只会调用初始化方法一次。<br>—————————–init方法中ServletConfig config 参数方法———————-<br>config.getServletName(); 获得servlet名称，返回字符串。<br>获取初始化参数，xml文件配置。<br><servlet><br><init-param><br><param-name>key</param-name><br><param-value>value</param-value><br></init-param><br></servlet><br>config.getInitParameter(“key”); 返回字符串，值为value。<br>获取ServletContext对象<br>ServletContext sc = config.getServletContext();<br>———————–xml中url-patten匹配形式—————————–<br>完全匹配、目录匹配、扩展名匹配<br>———————使用注解创建servlet———————-<br>@WebServlet(“/myServlet”);<br>相当于在xml文件中配置url<br>xml文件中 metadata-complete=”true” 不扫描注解改成false扫描注解<br>———————————————service方法———–<br>当servlet重写了service方法，无论发送什么请求，都会调用service方法不会调用doget或dopost方法。<br>原因：如果servlet当中没有存在service方法，就会到它的父类当中去找，在父类当中找到service是参数为ServletRequest，会在内部把参数转为httpServlet，转换完毕后会在继续调用参数为httpServletRequest的service方法，在此方法当中会获取参数的类型，根据不同的参数类型再去调用不同的方法。<br>——————————-ServletContext对象——————————-<br>服务器会为每一个工程创建一个对象，这个对象就是ServletContext对象。这个对象全局唯一，而且工程内部的所有servlet都共享这个对象。所以叫全局应用程序共享对象。<br>获取上下文：</absolute-ordering></p><p>通过init方法当中一个参数ServletConfig来获取<br>ServletConfig config<br>ServletContext sc = config.getServletContext();</p><p>调用本类的getServletContext()获得对象，本质还是通过init方法参数中的ServletConfig config对象当中的getServletContext()来获得对象。<br>如：this.getServletContext();<br>————————-ServletContext对象的使用方法——————————-<br>context.getRealPath(“a.txt”); 返回字符串，其路径为绝对路径，如项目名为biyeshiji。方法的返回值为 盘符:.…………………\biyeshiji\a.txt</p><p>1.getRealPath(“/“)方法返回的是项目在服务器的绝对路径，而getRealPath(“WEB-INF/myfile”)返回的是包含一个给定虚拟路径的绝对路径,其中/myfile是虚拟的。<br>2.getContextPath()方法返回的是项目相对路径，并不会返回其绝对的路径，就是说并不知道项目在哪个位置。</p><p>context.setAttribute(String name, Object value); 向ServletContext对象设置值<br>context.getAttribute(String name) 获取指定name的值<br>context.removeAttribute(String name) 删除指定name的值</p><p>域对象：能够存储数据的对象。<br>域对象：ServletContext、Session……………</p><p>———————————-读取文件—————————————————–<br>输入流就是把文件加载到程序里。让程序操作数据。<br>FileInputStream in = new FileInputStream(“文件绝对路径”); 加载本地文件<br>in.read() 读取一个字符，返回值为读取多少个字符，当文件读取完毕时返回一个-1<br>in.read(byte类型数组名); 把文件里的内容读取到数组中</p><p>in.close 关闭输入流<br>byte，即字节，由8位的二进制组成。<br>ASCII码：一个英文字母（不分大小写）占一个字节的空间，一个中文汉字占两个字节的空间。<br>UTF-8编码：一个英文字符等于一个字节，一个中文（含繁体）等于三个字节。中文标点占三个字节，英文标点占一个字节<br>Unicode编码：一个英文等于两个字节，一个中文（含繁体）等于两个字节。中文标点占两个字节，英文标点占两个字节<br>————————文件下载注意点—————————-<br>从服务器下载的图片、视频、声音文件。浏览器会自动解析，不会以附件的形式保存<br>————————–multipart/form-date格式————————-<br>type为text form-date; name=””</p><p>type为file form-data; name=””, filename=””<br>Content-Type:<br>————————–application/x-www-form-urlencoded—————————<br>只有普通key-value形式</p><p>Form-item 表单项<br>——————————文件上传———————————<br>以输入流的形式获取multipart请求的请求体内容<br>ServletInputStream is = request.getInputStream();</p><p>new String(buy, 0, len);<br>把一个字节数组buy从0取到len，取出来之后转换成String类型。</p><p>如果向浏览器发送二进制数，浏览器会自动解析它。</p><p>ServletFileUpload.isMultipartContent(request) 判断请求是否为multipart/form-date格式。<br>DiskFileItemFactory factory = new DiskFileItemFactory(); 创建一个fileitem工厂。<br>ServletFileUpload upload = new ServletFileUpload(factory); 创建文件上传核心组件。<br>upload.serHeaderEncoding(“UTF-8”); 设置每一个item的头部字符编码，其可以解决文件名的中文乱问题。<br>List<fileitem>items = upload.parseRequest(request); 解析请求，获取到所有的items<br>item.isFormField 判断item是否为普通表单项，是返回true。<br>item.getFieldName(); 获取到表单项名称。<br>item.getString(); 获取到表单项的值。<br>item.getString(“UTF-8”); 以utf-8的形式获取值<br>item.getName 获取上传文件原始名称。<br>InputStream is = item.getInputStream(); 获取到输入流<br>OutputStream os = new FileOutputStream(File); 获取输出流<br>os.write(buf, 0, len);<br>os.close;<br>is.close 关闭流</fileitem></p><p>—————————–文件上传注意点——————-<br>文件上传到服务器，必须分割成很多数据包，到达服务器肯定是无序的。所以有临时文件的概念，来接收数据包。<br>factory.setSizeThreshold(1024 * 1024 * 1)； 设置使用临时文件的边界值，大于该值，上传文件会先保存在临时文件中，否则，上传文件将直接写入到内存中<br>factory.setRepository(“路径字符串File类”) 设置临时文件夹<br>item.delete 删除临时文件<br>System.currentTimeMillis() System.currentTimeMillis()在java中是最常用的获取系统时间的方法，它返回的是1970年1月1日0点到现在经过的毫秒数。<br>upload.setFileSizeMax() 设置单个上传文件的最大边界值，单位为字节byte。<br>upload.setSizeMax(); 设置一次上传多个文件的最大边界值，单位为字节byte。<br>————————————–文件夹上限——————————————-<br>比如fat16下就只有最多512个文件或者目录；fat32格式下，一个特定文件夹中最多可以保存的子文件夹和文件的数量是65,534（但如果使用了长文件名，那么该数字会减小）；ntfs格式下，包含的文件个数的最大值是4,294,967,295个 (2^32 - 1)。<br>——————————–创建目录————————————–<br>java.io.File.mkdir()： 只能创建一级目录，且父目录必须存在，否则无法成功创建一个目录。<br>java.io.File.mkdirs()： 可以创建多级目录，父目录不一定存在。<br>file类中exists方法 检查文件或目录是否存在<br>File.separator 与系统有关的默认名称分隔符。此字段被初始化为包含系统属性 file.separator 的值的第一个字符。在 UNIX 系统上，此字段的值为 ‘/‘；在 Microsoft Windows 系统上，它为 ‘&#39;。</p><p>———————————-后台跳转连接——————————————————<br>它们的区别是什么？<br>request.getRequestDispatcher(“路径字符串”).forward(request, response);<br>response.sendRedirect(“路径字符串”);<br>———————–随机数——————–<br>random()方法，是返回一个[0,1)的浮点数。<br>—————————-web访问流程—————————–<br>找到主机-&gt;找到对应端口-&gt;engine引擎找到对应域名-&gt;通过全局xml文件找到对应项目-&gt;创建request和response对象-&gt;通过项目xml文件找到对应servlet，再把两个对象转到servlet。<br>request对象接收浏览器发送的数据<br>response写的内容会缓存到response缓冲区里面，tomcat除了读取response缓冲区中的内容，还会自动在tomcat生成的response对象中添加响应行、响应头。<br>—————————————设置response参数—————————————<br>response.setState(int code); 设置状态码<br>添加响应头信息：<br>response.addHeader(String, String);<br>response.addIntHeader(String, int);<br>response.addDateHeader(String, Date);<br>修改响应头：<br>response.setHeader(String, String);<br>response.setIntHeader(String, int);<br>response.setDateHeader(String, Date);</p><p>设置重定向：<br>response.setState(302);<br>response.setHeader(“location”, “/项目名称/servlet”);<br>重定向访问两次服务器，浏览器地址栏也会发生变化。<br>response.sendRedirect(“重定向地址”); 相当于上面两句话的意思。<br>response.setHeader(“refresh”,”3;url=<a href="http://www.baidu.com”" target="_blank" rel="noopener">http://www.baidu.com”</a>); 定时刷新重定向，每隔3秒钟去转发。</p><p>把写的内容存到response缓冲区中，默认使用的是iso8859的编码。<br>response.setCharacterEncoding(“UTF-8”); 设置缓冲区编码。<br>response.setHeader(“Content-Type”, “text/html;charset=UTF-8”);</p><p>简写： response.setContentType(“text/html;charset=UTF-8”);</p><p>——————————–request对象——————————-<br>request.getMethod(); 对去请求行，获取请求方式，放回字符串。<br>request.getRequestURL(); 获取浏览器url，放回StringBuffer。<br>request.getRequestURI(); 获取浏览器uri，放回String。<br>uri指的是URL中从项目名称到参数的内容。<br>获取url中get方式的请求参数：<br>request.getQueryString(); 返回String<br>获取URL中项目名称：<br>request.getContextPath(); 返回String类型。</p><p>获取请求头所有的名称 request.getHeaderNames(); 返回枚举类型。<br>根据名称获取指定的头信息：<br>request.getHeader(“referer”); 例如请求头中referer的值。<br>referer的含义：告诉服务器请求是哪个页面发送的，如果请求不是从页面发送的，不会referer属性。</p><p>请求体就是页面发送的参数。<br>request.getParameter(“name”); 获取请求体参数。<br>request.getParameterValues(“name”); 如果是复选框，获取多个值。<br>request.getParameterNames(); 获取所有参数名称，返回枚举类型。<br>request.getParameterMap(); 获取所有请求参数，返回map。</p><p>request.setCharacterEncoding(“UTF-8”); 设置post的编码，本方法对get方式无效。</p><p>BeanUtiles 第三方的jar包，把获取的请求参数封装成对象。</p><p>请求转发只需要发送一次请求，直接找servlet1，在servlet1当中直接转发给servlet2，浏览器中的地址栏不会发生改变。<br>RequestDispatcher disp = request.getRequestDispatcher(“转发url”); 获取转发器。<br>disp.forward(request, response); 将用户的请求，连同请求信息等内容，一起转发到服务器的另外一个servlet去处理，它不会丢失request信息。</p><p>request域对象 setAttribute(“key”, “value”); 存储值<br>getAttribute(“key”) 获取值<br>request域在一次请求当中数据是共享的，即转发，request对象发送一个请求是创建，请求结束时销毁。<br>Servlet的生命周期：当接收到第一次请求被创建直到服务器关闭，单例多线程。<br>转发中，涉及到多个servlet中的request对象，并不是同一个对象。转发就是把上一个request对象的信息交个要转发servlet的request对象。并不是同一个对象。<br>客户端地址：客户端访问服务器使用的地址，服务器外部地址，在写的时候要写上/项目名称/servlet的url<br>服务器端地址：在服务器内部当中使用的地址，不需要写项目名称，只写servlet的url就能访问。<br>mvc m是Javabean v是视图层 c是控制器<br>三层 web层 service层（对数据进行加工） dao层（从数据库取数据，封装成javabean交个service层）</p><p>——————————————————Spring———————————————————-<br>xml配置文件：<br><bean>id属性：唯一标识<br>class属性：类的路径<br><property>用于进行属性注入<br>name：bean的属性名，通过setter方法获得<br>一个方法名为setBookDao<br>BookDaobookDao<br>属性名为：bookDao<br>ref：另一个bean的id值的引用<br>依赖注入把对象的创造交给外部去管理,很好的解决了代码紧耦合的问题，是一种让代码实现松耦合的机制。<br>//创建spring容器<br>ApplicationContext applicationContext=new ClassPathXmlApplicationContext(xmlPath);<br>//生产实例<br>BookService bookService = (BookService)applicationContext.getBean(“bookServiceId”);<br>BeanFactory用于生产bean，采取延迟策略，第一次getBean时才会初始化。<br>ApplicationContext当配置文件被加载，就进行对象实例化。</property></bean></p><p>ClassPathXmlApplicationContext用于加载classpath（类路径、src）下的xml<br>FileSystemXmlApplicationContext用于加载指定盘符下的xml<br>/WEB-INF/…xml</p><p>类名.class, class.forName(), getClass() 获得字节码文件</p><p>静态工厂：<br>factory-method属性确定静态方法名。（这个静态方法返回对象）<br>考虑怎么生产bean，不要考虑其它的实现方法。<br>实例工厂：<br>factory-bean属性指定工厂实例，获得实例对象<br>factory-method属性指创建实例的方法</p><p>bean的作用域：用于确定spring创建bean的实例个数，默认singleton<br>singleton 在Spring loc容器中仅存在一个bean实例<br>prototype每次从容器中调用bean时，都返回一个新的实例。<br>scope属性用于设置bean的作用域。</p><p>设计模式<br>单例设计模式<br>必须要类中创建一个对象出来<br>1.私有化自己的构造方法（使用private关键字），不让创建出新的对象。<br>2.给外界创建一个方法，能够获得这个已经创建好的对象。<br>单例设计模式一般在编写工具类的时候使用。</p></div><div><div><div style="text-align:center;color:#ccc;font-size:22px;letter-spacing:12px">本文结束<i class="fa fa-paw"></i>感谢您的阅读</div></div></div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者： </strong>im乐</li><li class="post-copyright-link"><strong>本文链接：</strong> <a href="https://zero3737.gitee.io/posts/40121/" title="JAVA">https://zero3737.gitee.io/posts/40121/</a></li><li class="post-copyright-license"><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><footer class="post-footer"><div class="post-tags"><a href="/tags/JAVA/" rel="tag"><i class="fa fa-tag"></i> JAVA</a></div><div class="post-widgets"><div class="social_share"><div id="needsharebutton-postbottom"><span class="btn"><i class="fa fa-share-alt" aria-hidden="true"></i></span></div></div></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/posts/5063/" rel="next" title="Node.js"><i class="fa fa-chevron-left"></i> Node.js</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/posts/30389/" rel="prev" title="XML">XML <i class="fa fa-chevron-right"></i></a></div></div></footer></div></article></div></div><div class="comments" id="comments"></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">文章目录</li><li class="sidebar-nav-overview" data-target="site-overview-wrap">站点概览</li></ul><div class="site-overview-wrap sidebar-panel"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" src="/static/user_images/头像/avatar.gif" alt="im乐"><p class="site-author-name" itemprop="name">im乐</p><div class="site-description motion-element" itemprop="description">一个专注分享互联网知识的网站，希望你会喜欢它。</div></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">88</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">6</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">17</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="feed-link motion-element"><a href="/atom.xml" rel="alternate"><i class="fa fa-rss"></i> RSS</a></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/zero3737" title="GitHub &rarr; https://github.com/zero3737" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a> </span><span class="links-of-author-item"><a href="https://gitee.com/zero3737/" title="Gitee &rarr; https://gitee.com/zero3737/" rel="noopener" target="_blank"><i class="fa fa-fw fa-git"></i>Gitee</a></span></div><div class="links-of-blogroll motion-element links-of-blogroll-block"><div class="links-of-blogroll-title"><i class="fa fa-history fa-" aria-hidden="true"></i> 近期文章</div><ul class="links-of-blogroll-list"><li><a href="/posts/12fc1c4b/" title="JSP 教程" target="_blank">JSP 教程</a></li><li><a href="/posts/8dc1959/" title="JavaScript进阶之事件" target="_blank">JavaScript进阶之事件</a></li><li><a href="/posts/514ba138/" title="实例化对象（new）的过程" target="_blank">实例化对象（new）的过程</a></li><li><a href="/posts/77987eec/" title="JavaScript 中的原型链和函数原型" target="_blank">JavaScript 中的原型链和函数原型</a></li><li><a href="/posts/fed4be0c/" title="for…in 遍历对象中的属性" target="_blank">for…in 遍历对象中的属性</a></li></ul></div><script type="text/javascript" charset="utf-8" src="/js/tagcloud.js"></script><script type="text/javascript" charset="utf-8" src="/js/tagcanvas.js"></script><div class="widget-wrap"><h3 class="widget-title" style="text-align:center;color:#fc6423">Tag Cloud</h3><div id="myCanvasContainer" class="widget tagcloud"><canvas width="250" height="250" id="resCanvas" style="width:100%"><ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSS/">CSS</a><span class="tag-list-count">30</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git/">Git</a><span class="tag-list-count">7</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTML/">HTML</a><span class="tag-list-count">9</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JAVA/">JAVA</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScript/">JavaScript</a><span class="tag-list-count">7</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Windows/">Windows</a><span class="tag-list-count">11</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端/">前端</a><span class="tag-list-count">42</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/开发工具/">开发工具</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/教程/">教程</a><span class="tag-list-count">15</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/服务搭建/">服务搭建</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/未完待续/">未完待续</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/概念/">概念</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/科学上网/">科学上网</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/算法/">算法</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/网站推荐/">网站推荐</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/软件推荐/">软件推荐</a><span class="tag-list-count">2</span></li></ul></canvas></div></div></div></div><div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#JAVA-SE"><span class="nav-number">1.</span> <span class="nav-text">JAVA SE</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#准备"><span class="nav-number">1.1.</span> <span class="nav-text">准备</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#概念"><span class="nav-number">1.1.1.</span> <span class="nav-text">概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#jdk-目录说明"><span class="nav-number">1.1.2.</span> <span class="nav-text">jdk 目录说明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#配置-JAVA-环境"><span class="nav-number">1.1.3.</span> <span class="nav-text">配置 JAVA 环境</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#手动编译"><span class="nav-number">1.1.4.</span> <span class="nav-text">手动编译</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#基础"><span class="nav-number">1.2.</span> <span class="nav-text">基础</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#class"><span class="nav-number">1.2.1.</span> <span class="nav-text">class</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#包机制"><span class="nav-number">1.2.2.</span> <span class="nav-text">包机制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#package"><span class="nav-number">1.2.2.1.</span> <span class="nav-text">package</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#import"><span class="nav-number">1.2.2.2.</span> <span class="nav-text">import</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Object-类"><span class="nav-number">1.2.3.</span> <span class="nav-text">Object 类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#汉字编码"><span class="nav-number">1.2.4.</span> <span class="nav-text">汉字编码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内存"><span class="nav-number">1.2.5.</span> <span class="nav-text">内存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GC-垃圾回收机制"><span class="nav-number">1.2.6.</span> <span class="nav-text">GC 垃圾回收机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#输出输入"><span class="nav-number">1.2.7.</span> <span class="nav-text">输出输入</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#输出"><span class="nav-number">1.2.7.1.</span> <span class="nav-text">输出</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#输入"><span class="nav-number">1.2.7.2.</span> <span class="nav-text">输入</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#基本类型"><span class="nav-number">1.3.</span> <span class="nav-text">基本类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#默认长度"><span class="nav-number">1.3.1.</span> <span class="nav-text">默认长度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#默认值"><span class="nav-number">1.3.2.</span> <span class="nav-text">默认值</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数组"><span class="nav-number">1.4.</span> <span class="nav-text">数组</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#定义"><span class="nav-number">1.4.1.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Arrays-类"><span class="nav-number">1.4.2.</span> <span class="nav-text">Arrays 类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#可变参数"><span class="nav-number">1.4.3.</span> <span class="nav-text">可变参数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数值类型转换"><span class="nav-number">1.5.</span> <span class="nav-text">数值类型转换</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#自动类型转换"><span class="nav-number">1.5.1.</span> <span class="nav-text">自动类型转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#强制类型转换"><span class="nav-number">1.5.2.</span> <span class="nav-text">强制类型转换</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#变量作用域"><span class="nav-number">1.6.</span> <span class="nav-text">变量作用域</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#for-循环"><span class="nav-number">1.7.</span> <span class="nav-text">for 循环</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#foreach"><span class="nav-number">1.7.1.</span> <span class="nav-text">foreach</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#退出外层循环"><span class="nav-number">1.7.2.</span> <span class="nav-text">退出外层循环</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#final"><span class="nav-number">1.8.</span> <span class="nav-text">final</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#static"><span class="nav-number">1.9.</span> <span class="nav-text">static</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#静态代码块"><span class="nav-number">1.9.1.</span> <span class="nav-text">静态代码块</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#this-指针"><span class="nav-number">1.10.</span> <span class="nav-text">this 指针</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#this-说明"><span class="nav-number">1.10.1.</span> <span class="nav-text">this 说明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#super"><span class="nav-number">1.10.2.</span> <span class="nav-text">super</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#继承"><span class="nav-number">1.11.</span> <span class="nav-text">继承</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#关系"><span class="nav-number">1.11.1.</span> <span class="nav-text">关系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#访问权限"><span class="nav-number">1.11.2.</span> <span class="nav-text">访问权限</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类的类型转换"><span class="nav-number">1.11.3.</span> <span class="nav-text">类的类型转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#instanceof"><span class="nav-number">1.11.4.</span> <span class="nav-text">instanceof</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#重写和重载"><span class="nav-number">1.11.5.</span> <span class="nav-text">重写和重载</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#重写"><span class="nav-number">1.11.5.1.</span> <span class="nav-text">重写</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#重载"><span class="nav-number">1.11.5.2.</span> <span class="nav-text">重载</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#多态"><span class="nav-number">1.12.</span> <span class="nav-text">多态</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#abstract（抽象）"><span class="nav-number">1.12.1.</span> <span class="nav-text">abstract（抽象）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#接口"><span class="nav-number">1.12.2.</span> <span class="nav-text">接口</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#抽象类和接口的区别"><span class="nav-number">1.12.2.1.</span> <span class="nav-text">抽象类和接口的区别</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#泛型"><span class="nav-number">1.13.</span> <span class="nav-text">泛型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#泛型类"><span class="nav-number">1.13.1.</span> <span class="nav-text">泛型类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#泛型接口"><span class="nav-number">1.13.2.</span> <span class="nav-text">泛型接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#泛型方法"><span class="nav-number">1.13.3.</span> <span class="nav-text">泛型方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#泛型通配符"><span class="nav-number">1.13.4.</span> <span class="nav-text">泛型通配符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#泛型的擦除"><span class="nav-number">1.13.5.</span> <span class="nav-text">泛型的擦除</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#泛型注意点"><span class="nav-number">1.13.6.</span> <span class="nav-text">泛型注意点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#匿名对象"><span class="nav-number">1.14.</span> <span class="nav-text">匿名对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#包装类"><span class="nav-number">1.15.</span> <span class="nav-text">包装类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内部类"><span class="nav-number">1.16.</span> <span class="nav-text">内部类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#实例内部类"><span class="nav-number">1.16.1.</span> <span class="nav-text">实例内部类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#静态内部类"><span class="nav-number">1.16.2.</span> <span class="nav-text">静态内部类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#局部内部类"><span class="nav-number">1.16.3.</span> <span class="nav-text">局部内部类</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#String"><span class="nav-number">2.</span> <span class="nav-text">String</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#方法"><span class="nav-number">2.1.</span> <span class="nav-text">方法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#随机数"><span class="nav-number">3.</span> <span class="nav-text">随机数</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#时间戳"><span class="nav-number">4.</span> <span class="nav-text">时间戳</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#概念-1"><span class="nav-number">4.1.</span> <span class="nav-text">概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用"><span class="nav-number">4.2.</span> <span class="nav-text">使用</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#UUID"><span class="nav-number">5.</span> <span class="nav-text">UUID</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#概念-2"><span class="nav-number">5.1.</span> <span class="nav-text">概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用-1"><span class="nav-number">5.2.</span> <span class="nav-text">使用</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#常量"><span class="nav-number">6.</span> <span class="nav-text">常量</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#JAVA-三层架构"><span class="nav-number">7.</span> <span class="nav-text">JAVA 三层架构</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#MVC-模式"><span class="nav-number">8.</span> <span class="nav-text">MVC 模式</span></a></li></ol></div></div></div><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span id="scrollpercent"><span>0</span>%</span></div></div></aside><div id="sidebar-dimmer"></div></div></main><div id="landlord"><div class="message" style="opacity:0"></div><canvas id="live2d" width="300" height="380" class="live2d"></canvas></div><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; 2018 – <span itemprop="copyrightYear">2022</span> <span class="with-love" id="animate"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">im乐</span> <span class="post-meta-divider footer-ages-icon">|</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-area-chart"></i> </span><span title="站点总字数">292k</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span title="站点阅读时长">4:25</span></div><div class="busuanzi-count"><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span class="post-meta-item-icon"><i class="fa fa-user"></i> </span><span>访问人数</span> <span class="site-uv" title="总访客量"><span class="busuanzi-value" id="busuanzi_value_site_uv"></span> </span><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span>总访问量</span> <span class="site-pv" title="总访问量"><span class="busuanzi-value" id="busuanzi_value_site_pv"></span></span></div><div><script type="text/javascript">document.write(unescape("%3Cspan id='cnzz_stat_icon_1278758248'%3E%3C/span%3E%3Cscript src='https://s9.cnzz.com/z_stat.php%3Fid%3D1278758248%26online%3D1%26show%3Dline' type='text/javascript'%3E%3C/script%3E"))</script></div></div></footer></div><script>"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script color="0,0,255" opacity="0.5" zindex="-1" count="99" src="//cdn.jsdelivr.net/gh/theme-next/theme-next-canvas-nest@1/canvas-nest.min.js"></script><script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><script src="//cdn.jsdelivr.net/npm/fastclick@1/lib/fastclick.min.js"></script><script src="//cdn.jsdelivr.net/npm/jquery-lazyload@1/jquery.lazyload.min.js"></script><script src="//cdn.jsdelivr.net/npm/velocity-animate@1/velocity.min.js"></script><script src="//cdn.jsdelivr.net/npm/velocity-animate@1/velocity.ui.min.js"></script><script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script><script src="/lib/reading_progress/reading_progress.js"></script><script src="/js/utils.js?v=7.1.2"></script><script src="/js/motion.js?v=7.1.2"></script><script src="/js/affix.js?v=7.1.2"></script><script src="/js/schemes/pisces.js?v=7.1.2"></script><script src="/js/scrollspy.js?v=7.1.2"></script><script src="/js/post-details.js?v=7.1.2"></script><script src="/js/next-boot.js?v=7.1.2"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><script>var GUEST=["nick","mail","link"],guest="nick,mail";guest=guest.split(",").filter(function(e){return GUEST.indexOf(e)>-1}),new Valine({el:"#comments",verify:!1,notify:!1,appId:"G2263okNhhWmY54fzXVhqqXV-MdYXbMMI",appKey:"c3Mz0H4v2spiQybEgul3ScwD",placeholder:"请输入你的内容",avatar:"mm",meta:guest,pageSize:"10",visitor:!0,lang:"zh-cn"})</script><script>function proceedsearch(){$("body").append('<div class="search-popup-overlay local-search-pop-overlay"></div>').css("overflow","hidden"),$(".search-popup-overlay").click(onPopupClose),$(".popup").toggle();var e=$("#local-search-input");e.attr("autocapitalize","none"),e.attr("autocorrect","off"),e.focus()}var isfetched=!1,isXml=!0,search_path="search.xml";0===search_path.length?search_path="search.xml":/json$/i.test(search_path)&&(isXml=!1);var path="/"+search_path,onPopupClose=function(e){$(".popup").hide(),$("#local-search-input").val(""),$(".search-result-list").remove(),$("#no-result").remove(),$(".local-search-pop-overlay").remove(),$("body").css("overflow","")},searchFunc=function(e,t,o){"use strict";$("body").append('<div class="search-popup-overlay local-search-pop-overlay"><div id="search-loading-icon"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div>').css("overflow","hidden"),$("#search-loading-icon").css("margin","20% auto 0 auto").css("text-align","center"),$.ajax({url:e,dataType:isXml?"xml":"json",async:!0,success:function(e){isfetched=!0,$(".popup").detach().appendTo(".header-inner");var n=isXml?$("entry",e).map(function(){return{title:$("title",this).text(),content:$("content",this).text(),url:$("url",this).text()}}).get():e,r=document.getElementById(t),s=document.getElementById(o),a=function(){var e=r.value.trim().toLowerCase(),t=e.split(/[\s\-]+/);t.length>1&&t.push(e);var o=[];if(e.length>0&&n.forEach(function(n){function r(t,o,n,r){for(var s=r[r.length-1],a=s.position,i=s.word,l=[],h=0;a+i.length<=n&&0!=r.length;){i===e&&h++,l.push({position:a,length:i.length});var p=a+i.length;for(r.pop();0!=r.length&&(s=r[r.length-1],a=s.position,i=s.word,p>a);)r.pop()}return c+=h,{hits:l,start:o,end:n,searchTextCount:h}}function s(e,t){var o="",n=t.start;return t.hits.forEach(function(t){o+=e.substring(n,t.position);var r=t.position+t.length;o+='<b class="search-keyword">'+e.substring(t.position,r)+"</b>",n=r}),o+=e.substring(n,t.end)}var a=!1,i=0,c=0,l=n.title.trim(),h=l.toLowerCase(),p=n.content.trim().replace(/<[^>]+>/g,""),u=p.toLowerCase(),f=decodeURIComponent(n.url).replace(/\/{2,}/g,"/"),d=[],g=[];if(""!=l&&(t.forEach(function(e){function t(e,t,o){var n=e.length;if(0===n)return[];var r=0,s=[],a=[];for(o||(t=t.toLowerCase(),e=e.toLowerCase());(s=t.indexOf(e,r))>-1;)a.push({position:s,word:e}),r=s+n;return a}d=d.concat(t(e,h,!1)),g=g.concat(t(e,u,!1))}),(d.length>0||g.length>0)&&(a=!0,i=d.length+g.length)),a){[d,g].forEach(function(e){e.sort(function(e,t){return t.position!==e.position?t.position-e.position:e.word.length-t.word.length})});var v=[];0!=d.length&&v.push(r(l,0,l.length,d));for(var $=[];0!=g.length;){var C=g[g.length-1],m=C.position,x=C.word,w=m-20,y=m+80;0>w&&(w=0),y<m+x.length&&(y=m+x.length),y>p.length&&(y=p.length),$.push(r(p,w,y,g))}$.sort(function(e,t){return e.searchTextCount!==t.searchTextCount?t.searchTextCount-e.searchTextCount:e.hits.length!==t.hits.length?t.hits.length-e.hits.length:e.start-t.start});var T=parseInt("1");T>=0&&($=$.slice(0,T));var b="";b+=0!=v.length?"<li><a href='"+f+"' class='search-result-title'>"+s(l,v[0])+"</a>":"<li><a href='"+f+"' class='search-result-title'>"+l+"</a>",$.forEach(function(e){b+="<a href='"+f+'\'><p class="search-result">'+s(p,e)+"...</p></a>"}),b+="</li>",o.push({item:b,searchTextCount:c,hitCount:i,id:o.length})}}),1===t.length&&""===t[0])s.innerHTML='<div id="no-result"><i class="fa fa-search fa-5x"></i></div>';else if(0===o.length)s.innerHTML='<div id="no-result"><i class="fa fa-frown-o fa-5x"></i></div>';else{o.sort(function(e,t){return e.searchTextCount!==t.searchTextCount?t.searchTextCount-e.searchTextCount:e.hitCount!==t.hitCount?t.hitCount-e.hitCount:t.id-e.id});var a='<ul class="search-result-list">';o.forEach(function(e){a+=e.item}),a+="</ul>",s.innerHTML=a}};r.addEventListener("input",a),$(".local-search-pop-overlay").remove(),$("body").css("overflow",""),proceedsearch()}})};$(".popup-trigger").click(function(e){e.stopPropagation(),isfetched===!1?searchFunc(path,"local-search-input","local-search-result"):proceedsearch()}),$(".popup-btn-close").click(onPopupClose),$(".popup").click(function(e){e.stopPropagation()}),$(document).on("keyup",function(e){var t=27===e.which&&$(".search-popup").is(":visible");t&&onPopupClose()})</script><script>!function(){var t=document.createElement("script"),s=window.location.protocol.split(":")[0];"https"===s?t.src="https://zz.bdstatic.com/linksubmit/push.js":t.src="http://push.zhanzhang.baidu.com/push.js";var e=document.getElementsByTagName("script")[0];e.parentNode.insertBefore(t,e)}()</script><script src="//cdn.jsdelivr.net/gh/theme-next/theme-next-needmoreshare2@1/needsharebutton.min.js"></script><script>pbOptions={},pbOptions.iconStyle="default",pbOptions.boxForm="horizontal",pbOptions.position="bottomCenter",pbOptions.networks="Wechat,QQZone,Weibo,Douban,Mailto",new needShareButton("#needsharebutton-postbottom",pbOptions)</script><script>$(".highlight").not(".gist .highlight").each(function(t,e){var n=$("<div>").addClass("highlight-wrap");$(e).after(n),n.append($("<button>").addClass("copy-btn").append("复制").on("click",function(t){var e=$(this).parent().find(".code").find(".line").map(function(t,e){return $(e).text()}).toArray().join("\n"),n=document.createElement("textarea"),o=window.pageYOffset||document.documentElement.scrollTop;n.style.top=o+"px",n.style.position="absolute",n.style.opacity="0",n.readOnly=!0,n.value=e,document.body.appendChild(n);const a=document.getSelection(),i=a.rangeCount>0?a.getRangeAt(0):!1;n.select(),n.setSelectionRange(0,e.length),n.readOnly=!1;var l=document.execCommand("copy");l?$(this).text("复制成功"):$(this).text("复制失败"),n.blur(),$(this).blur(),i&&(a.removeAllRanges(),a.addRange(i))})).on("mouseleave",function(t){var e=$(this).find(".copy-btn");setTimeout(function(){e.text("复制")},300)}).append(e)})</script><canvas class="fireworks" width="2500" height="856" style="width:1250px;height:428px"></canvas><script src="https://cdn.jsdelivr.net/npm/animejs@2.2.0/anime.min.js"></script><script src="/static/js/cursor/fireworks2.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/moment.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment-precise-range-plugin@1.3.0/moment-precise-range.min.js"></script><script>function timer() {
      var ages = moment.preciseDiff(moment(),moment(20190601,"YYYYMMDD"));
      //去除时分秒信息
      ages = ages.replace(/\s?\d{0,2}\s+hours?/, "");
      ages = ages.replace(/\s?\d{0,2}\s+minutes?/, "");
      ages = ages.replace(/\s?\d{0,2}\s+seconds?/, "");
      //将年月日转换为中文
      ages = ages.replace(/years?/, "年");
      ages = ages.replace(/months?/, "月");
      ages = ages.replace(/days?/, "天");
      ages = ages.replace(/\d+/g, '<span style="color:#1094e8">$&</span>');
      span.innerHTML = `网站已经运行 ${ages}`;
    }
    var span = document.createElement("span");
    //插入到agesicon之后
    var agesicon = document.querySelector(".footer-ages-icon");
    console.log(agesicon);
    document.querySelector(".copyright").insertBefore(span, agesicon.nextSibling);
    timer();</script><script>!function(e,t,o,c,i,a,n){e.DaoVoiceObject=i,e[i]=e[i]||function(){(e[i].q=e[i].q||[]).push(arguments)},e[i].l=1*new Date,a=t.createElement(o),n=t.getElementsByTagName(o)[0],a.async=1,a.src=c,a.charset="utf-8",n.parentNode.insertBefore(a,n)}(window,document,"script",("https:"==document.location.protocol?"https:":"http:")+"//widget.daovoice.io/widget/bf66604c.js","daovoice"),daovoice("init",{app_id:"bf66604c"}),daovoice("update")</script><script type="text/javascript">var message_Path="/live2d/",home_Path="https://zero3737.gitee.io/"</script><script type="text/javascript" defer src="/live2d/js/message.js"></script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,debug:!1,model:{jsonPath:"/live2dw/assets/assets/z16.model.json"},display:{position:"right",width:300,height:400},mobile:{show:!1},react:{opacity:.7},log:!1})</script></body></html><!-- rebuild by neat -->