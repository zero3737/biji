<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>im乐</title>
  
  <subtitle>Efforts may not lead to success, but please don&#39;t be discouraged</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://zero3737.gitee.io/"/>
  <updated>2022-09-17T18:37:23.592Z</updated>
  <id>https://zero3737.gitee.io/</id>
  
  <author>
    <name>im乐</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JSP 教程</title>
    <link href="https://zero3737.gitee.io/posts/12fc1c4b/"/>
    <id>https://zero3737.gitee.io/posts/12fc1c4b/</id>
    <published>2020-05-11T15:38:03.000Z</published>
    <updated>2022-09-17T18:37:23.592Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Sep 24 2022 00:07:49 GMT+0800 (GMT+08:00) --><h2 id="JSP-生命周期"><a href="#JSP-生命周期" class="headerlink" title="JSP 生命周期"></a>JSP 生命周期</h2><p>JSP 生命周期就是从创建到销毁的整个过程，类似于 servlet 生命周期，区别在于 JSP 生命周期还包括将 JSP 文件编译成 servlet。</p><h3 id="JSP-编译"><a href="#JSP-编译" class="headerlink" title="JSP 编译"></a>JSP 编译</h3><p>当浏览器请求 JSP 页面时，JSP 引擎会首先去检查是否需要编译这个文件。如果这个文件没有被编译过，或者在上次编译后被更改过，则编译这个 JSP 文件。</p><p>编译的过程包括三个步骤：</p><ol><li>解析 JSP 文件。</li><li>将 JSP 文件转为 servlet。</li><li>编译 servlet。</li></ol><h3 id="JSP-初始化"><a href="#JSP-初始化" class="headerlink" title="JSP 初始化"></a>JSP 初始化</h3><p>容器载入 JSP 文件后，它会在为请求提供任何服务前调用 jspInit() 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">jspInit</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 初始化代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="JSP-执行"><a href="#JSP-执行" class="headerlink" title="JSP 执行"></a>JSP 执行</h3><p>这一阶段描述了 JSP 生命周期中一切与请求相关的交互行为，直到被销毁。当 JSP 网页完成初始化后，JSP 引擎将会调用_jspService() 方法。</p><p>_jspService() 方法需要一个 HttpServletRequest 对象和一个 HttpServletResponse 对象作为它的参数，就像下面这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">_jspService</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 服务端处理代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="JSP-清理"><a href="#JSP-清理" class="headerlink" title="JSP 清理"></a>JSP 清理</h3><p>JSP 生命周期的销毁阶段描述了当一个 JSP 网页从容器中被移除时所发生的一切。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">jspDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 清理代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JSP-语法"><a href="#JSP-语法" class="headerlink" title="JSP 语法"></a>JSP 语法</h2><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;%</span><br><span class="line">    JAVA 代码</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure><p>等价语句：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;jsp:scriptlet&gt;</span><br><span class="line">    代码片段</span><br><span class="line">&lt;/jsp:scriptlet&gt;</span><br></pre></td></tr></table></figure><p>注意：脚本程序中的代码会翻译到 _jspService 方法内部。</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;%! <span class="keyword">int</span> i = <span class="number">0</span>; %&gt;</span><br><span class="line">&lt;%! <span class="keyword">int</span> a, b, c; %&gt;</span><br><span class="line">&lt;%! Circle a = <span class="keyword">new</span> Circle(<span class="number">2.0</span>); %&gt;</span><br></pre></td></tr></table></figure><p>等价语句：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;jsp:declaration&gt;</span><br><span class="line">    代码片段</span><br><span class="line">&lt;/jsp:declaration&gt;</span><br></pre></td></tr></table></figure><p>注意：声明语句块中的内容，将被 JSP 引擎翻译成 Servlet 成员的内容，是不会被包含到 _jspService 方法中的。</p><p>一个 JSP 表达式中包含的脚本语言表达式，先被转化成 String，然后插入到表达式出现的地方。由于表达式的值会被转化成 String，所以您可以在一个文本行中使用表达式而不用去管它是否是 HTML 标签。</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%= 表达式 %&gt;</span><br></pre></td></tr></table></figure><p>等价语句：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;jsp:expression&gt;</span><br><span class="line">   表达式</span><br><span class="line">&lt;/jsp:expression&gt;</span><br></pre></td></tr></table></figure><p>注意：JSP 表达式中的代码会翻译到 _jspService 方法内部。</p><h2 id="JSP-注释"><a href="#JSP-注释" class="headerlink" title="JSP 注释"></a>JSP 注释</h2><p>JSP 文件中可以写 HTML 注释、JAVA 注释和注释。</p><table><thead><tr><th>语法</th><th></th></tr></thead><tbody><tr><td><code>&lt;%-- 注释 --%&gt;</code></td><td>JSP 注释，只能在 JSP 文件中查看</td></tr><tr><td><code>&lt;!-- 注释 --&gt;</code></td><td>HTML 注释，可以在浏览器源码、JSP 文件和 Servlet 中查看</td></tr><tr><td><code>// 注释</code></td><td>JAVA 单行注释，可以在 JSP 文件中和 Servlet 中查看</td></tr><tr><td><code>/* 注释 */</code></td><td>JAVA 多行注释</td></tr></tbody></table><p>注意：除了 JAVA 注释写在脚本程序中，HTML 注释和 JSP 注释只能写在脚本程序外。</p><h2 id="JSP-指令"><a href="#JSP-指令" class="headerlink" title="JSP 指令"></a>JSP 指令</h2><p>JSP 指令用来设置与整个 JSP 页面相关的属性。</p><table><thead><tr><th>指令</th><th>描述</th></tr></thead><tbody><tr><td><code>&lt;%@ page ... %&gt;</code></td><td>定义页面的依赖属性，比如脚本语言、error 页面、缓存需求等等</td></tr><tr><td><code>&lt;%@ include ... %&gt;</code></td><td>包含其他文件</td></tr><tr><td><code>&lt;%@ taglib ... %&gt;</code></td><td>引入标签库的定义，可以是自定义标签</td></tr></tbody></table><h3 id="page-指令"><a href="#page-指令" class="headerlink" title="page 指令"></a>page 指令</h3><p>page 指令包含多个相关属性，用于设置 JSP 的功能。</p><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>contentType</td><td>指定当前 JSP 页面的 MIME 类型和字符编码</td></tr><tr><td>import</td><td>导入要使用的 Java 类</td></tr><tr><td>language</td><td>定义 JSP 页面所用的脚本语言，默认是 Java（只支持 JAVA）</td></tr><tr><td>pageEncoding</td><td>设置文件编码</td></tr><tr><td>session</td><td>指定当前 JSP 页面是否能获得当前用户的 session 对象，默认是 true</td></tr><tr><td>errorPage</td><td>指定当 JSP 页面发生异常时需要转向的错误处理页面</td></tr><tr><td>isErrorPage</td><td>指定当前页面是否为异常页，只有该值为 true 时才能获取 exception 对象</td></tr><tr><td>extends</td><td>指定编译后的servlet继承哪一个类</td></tr></tbody></table><h2 id="JSP-动作元素"><a href="#JSP-动作元素" class="headerlink" title="JSP 动作元素"></a>JSP 动作元素</h2><p><code>&lt;jsp:include&gt;</code> 动作元素</p><p>动态包含和静态包含区别是否单独生成java文件不一样</p><h2 id="隐式对象"><a href="#隐式对象" class="headerlink" title="隐式对象"></a>隐式对象</h2><h2 id="九大内置对象和四大作用域"><a href="#九大内置对象和四大作用域" class="headerlink" title="九大内置对象和四大作用域"></a>九大内置对象和四大作用域</h2><h2 id="EL表达式"><a href="#EL表达式" class="headerlink" title="EL表达式"></a>EL表达式</h2><p>目的减少jsp脚本的编写。主要从四大域中取数据。</p><p>EL表达式可以简写，依次从pageContext域、request域、session域、application域中获取数据。</p><p>EL表达式内置11对象</p><p>EL执行表达式</p><p>EL表达式获取对象的值，直接写属性名即可，不用写getter、setter方法获取。</p><h2 id="JSTL"><a href="#JSTL" class="headerlink" title="JSTL"></a>JSTL</h2><p>JSP标准标签库，可以嵌入在jsp页面中使用标签的形式完成业务逻辑等功能。</p><p>jstl可以很方便的包含html标签。</p><h3 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h3><ol><li>引入jar包</li><li>通过taglib引入标签库</li></ol><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>if</p><p>foreach 自动把数据存到page域中</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">foreach begin=<span class="number">0</span> end=<span class="number">5</span> <span class="keyword">var</span>=i</span><br><span class="line">    $&#123;i&#125;</span><br><span class="line">feoreach</span><br></pre></td></tr></table></figure><p>foreach 遍历 list</p><p>foreach map</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sat Sep 24 2022 00:07:49 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;JSP-生命周期&quot;&gt;&lt;a href=&quot;#JSP-生命周期&quot; class=&quot;headerlink&quot; title=&quot;JSP 生命周期&quot;&gt;&lt;
      
    
    </summary>
    
    
      <category term="后端" scheme="https://zero3737.gitee.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="教程" scheme="https://zero3737.gitee.io/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="JAVA" scheme="https://zero3737.gitee.io/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript进阶之事件</title>
    <link href="https://zero3737.gitee.io/posts/8dc1959/"/>
    <id>https://zero3737.gitee.io/posts/8dc1959/</id>
    <published>2020-04-23T18:40:39.000Z</published>
    <updated>2022-09-17T18:37:23.597Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Sep 24 2022 00:07:49 GMT+0800 (GMT+08:00) --><p>本文主要介绍 JavaScript 中事件的相关概念以及常用事件。</p><a id="more"></a><hr><h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><ul><li><p>事件三要素：事件源、事件 和 事件驱动程序。</p></li><li><p>事件绑定可以分为匿名函数绑定和函数名绑定。</p><ul><li><p>匿名函数绑定：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">事件 = function() &#123;</span><br><span class="line"></span><br><span class="line">    事件驱动程序；</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>函数名绑定：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function 函数名 () &#123;</span><br><span class="line"></span><br><span class="line">    事件驱动程序；</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">事件 = 函数名；</span><br></pre></td></tr></table></figure></li></ul></li><li><p>循环中绑定事件问题，实质是同步和异步问题：</p><ul><li>for 循环是同步事件。</li><li>执行事件驱动程序是异步事件。</li><li>浏览器解析 js 代码，会把 for 自动执行。</li><li>而执行事件驱动程序需要用户触发事件才能执行。当事件驱动程序要访问 for 循环中的变量，for 循环已经执行完毕。所以每次访问的变量都是相同的值。</li></ul></li><li><p>return false 和 return 的区别？</p><ul><li>return 返回 null，起到中断方法执行的效果，只要不 return false 事件处理函数将会继续执行，表单将提交。</li><li>return false，事件处理函数会取消事件，不再继续向上冒泡。比如表单将终止提交。</li><li>在标签中绑定事件，必须在标签中 return false（阻止事件冒泡），在事件处理函数内 return false 不会阻止事件冒泡。在 JS 文件中绑定事件，在事件处理函数内 return false 可以阻止事件冒泡。</li></ul></li><li><p>注册事件</p><ul><li>通过元素的事件属性、 addEventListener() 以及 attachEvent() 方法进行事件的注册。</li></ul></li><li><p>注销事件</p><ul><li>通过 removeEventListener()、detachEvent() 以及事件属性赋值为 null 来进行事件的注销。</li><li>给对象的事件属性赋值为 null，可取消此事件的所有注册过的处理事件程序。</li></ul></li><li><p>事件传播三个阶段：事件捕获、事件目标阶段、事件冒泡。</p><ul><li>事件传播顺序：<ol><li>先从根节点向下执行捕获回调函数，一直到实际触发事件的元素的父元素位置，捕获过程结束。</li><li>然后事件传播到实际触发事件的 DOM 元素上，为事件目标阶段。</li><li>在事件目标阶段，无论 addEventListener 函数第三个参数是 true 还是 false 绑定的回调函数都会执行。事件的执行顺序按回调函数的添加顺序执行。</li><li>事件冒泡阶段开始。</li></ol></li><li>事件冒泡浏览器默认开启，事件捕获默认关闭。同一事件处理函数在捕获阶段和冒泡阶段可以先后执行。</li></ul></li><li><p>事件循环</p><ul><li><p>执行循序：</p><ol><li>同步和异步任务分别进入不同的执行”场所”，同步的进入主线程，异步的进入 Event Table 并注册函数。</li><li>当指定的事情完成时，Event Table 会将这个函数移入 Event Queue。</li><li>主线程内的任务执行完毕为空，会去 Event Queue 读取对应的函数，进入主线程执行。</li><li>上述过程会不断重复。</li></ol></li><li><p>js 引擎存在 monitoring process 进程，会持续不断的检查主线程执行栈是否为空，一旦为空，就会去 Event Queue 那里检查是否有等待被调用的函数。</p></li><li><p>定时器是异步执行的。</p><ul><li><code>setTimeout( fn, 0 )</code>的含义是：主线程执行栈内的同步任务全部执行完成，栈为空就马上执行。该函数最低延时 4 毫秒。</li><li>setInterval 的回调函数 fn 执行时间超过了延迟时间 ms，那么就完全看不出来有时间间隔了。</li></ul></li><li><p>宏任务和微任务。</p><ul><li>macro-task（宏任务）：包括整体代码 script, setTimeout, setInterval</li><li>micro-task（微任务）：Promise, process.nextTick</li><li>事件循环任务执行循序。<ul><li>进入整体代码（宏任务）后，开始第一次循环。接着执行所有的微任务。然后再次从宏任务开始，找到其中一个任务队列执行完毕，再执行所有的微任务。</li></ul></li></ul></li></ul></li></ul><h3 id="DOM-对象拥有的事件属性"><a href="#DOM-对象拥有的事件属性" class="headerlink" title="DOM 对象拥有的事件属性"></a>DOM 对象拥有的事件属性</h3><h4 id="鼠标事件"><a href="#鼠标事件" class="headerlink" title="鼠标事件"></a>鼠标事件</h4><ul><li>onclick 点击事件会在对象被点击时发生。</li><li>onmousedown 事件会在鼠标按键被按下时发生。<ul><li>onmousedown 和 onclick 的区别：<ul><li>onclick 是在鼠标点击弹起之后触发的事件。</li><li>onmousedown 是在鼠标按下之后触发的事件。</li></ul></li></ul></li><li>onmouseup 当鼠标弹起时触发。</li><li>ondblclick 事件会在对象被双击时发生。</li><li>onmouseover 事件会在鼠标指针移动到指定的对象上时发生。</li><li>onmouseout 事件会在鼠标指针移出指定的对象时发生。</li><li>onmousemove 事件会在指定对象移动 1 像素时触发，频率非常高。</li></ul><h4 id="键盘事件"><a href="#键盘事件" class="headerlink" title="键盘事件"></a>键盘事件</h4><ul><li>onkeyup 某个键盘按键被松开触发。</li></ul><h4 id="表单事件"><a href="#表单事件" class="headerlink" title="表单事件"></a>表单事件</h4><ul><li>onfocus 获得焦点。</li><li>onblur 失去焦点。</li><li>onchange 事件会在域的内容改变时发生。<ul><li>支持该事件的 HTML 标签：<ul><li>&lt;input type=”text”&gt;, &lt;select&gt;, &lt;textarea&gt;</li></ul></li><li>支持该事件的 JavaScript 对象：<ul><li>fileUpload, select, text, textarea。</li><li>当用于 select 元素时，change 事件会在<strong>选择某个选项</strong>时发生。</li><li>当用于 text field 或 text area 时，该事件会在元素<strong>失去焦点</strong>时发生。</li></ul></li></ul></li><li>oninput 用户<strong>输入时</strong>触发。<ul><li>该事件在 &lt;input&gt; 或 &lt;textarea&gt; 元素的值发生改变时触发。</li></ul></li><li></li></ul><h4 id="框架-对象（Frame-Object）事件"><a href="#框架-对象（Frame-Object）事件" class="headerlink" title="框架/对象（Frame/Object）事件"></a>框架/对象（Frame/Object）事件</h4><ul><li>onload 加载事件在页面内容加载完成之后立即执行相应的函数。</li><li>DOMContentLoaded 事件触发时，仅当 DOM 加载完成，不包括样式表，图片，flash。<ul><li>DOM 文档加载的步骤为：<ol><li>解析 HTML 结构。</li><li>加载外部脚本和样式表文件。</li><li>解析并执行脚本代码。</li><li>DOM 树构建完成。//DOMContentLoaded</li><li>加载图片等外部文件。</li><li>页面加载完毕。 //load</li></ol></li></ul></li><li>onscroll 事件在元素滚动条在滚动时触发。</li><li>onresize 事件会在窗口或框架被调整大小时发生。</li></ul><h4 id="动画事件"><a href="#动画事件" class="headerlink" title="动画事件"></a>动画事件</h4><ul><li>animationend 该事件在 CSS 动画结束播放时触发。</li></ul><h3 id="event-对象"><a href="#event-对象" class="headerlink" title="event 对象"></a>event 对象</h3><ul><li>只要触发 DOM 上的某个事件时，会产生一个事件对象 event，<strong>默认传参给事件驱动函数</strong>，这个对象中包含着所有与事件有关的信息。</li><li>所有浏览器都支持 event 对象，但支持的方式不同。比如 IE6-8 只能通过 window.event 获取事件对象，而其他的则可以直接获取。<ul><li>兼容性的写法：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var event = event || window.event;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="event-对象中的属性"><a href="#event-对象中的属性" class="headerlink" title="event 对象中的属性"></a>event 对象中的属性</h4><ul><li>clientX 光标相对于该网页（可视区域，不算滚动条）的水平位置。</li><li>clientY 光标相对于该网页（可视区域，不算滚动条）的垂直位置。</li><li>pageX 光标相对于该网页（算滚动条）的水平位置（不适用与 IE）。</li><li>pageY 光标相对于该网页（算滚动条）的垂直位置（不适用与 IE）。</li><li>screenX 光标相对于该屏幕的水平位置。</li><li>screenY 光标相对于该屏幕的水平位置。</li><li>type 事件的类型。</li><li>target 获取该事件是由哪个事件源产生。<ul><li>js 中发生事件冒泡，this 指向就会改变的，但 event.target 不会变化，它永远指向触发事件的 DOM 元素本身。运用这个特点，可以实现事件委托。</li></ul></li></ul><h4 id="event-对象中的-API"><a href="#event-对象中的-API" class="headerlink" title="event 对象中的 API"></a>event 对象中的 API</h4><p>preventDefault() 通知 Web 浏览器不要执行与事件关联的<strong>默认动作</strong>。</p><p>stopPropagation() 停止事件的传播，阻止它被分派到其他 Document 节点。</p><h2 id="BOM-DOM"><a href="#BOM-DOM" class="headerlink" title="BOM/DOM"></a>BOM/DOM</h2><ul><li>DOM：JavaScript 操作网页上的元素 API。</li><li>BOM：JavaScript 操作浏览器的部分功能 API。<ul><li>BOM 缺乏标准，JavaScript 语法的标准化组织是 ECMA，DOM 的标准化组织是 W3C。</li></ul></li><li>所有全局的变量和方法都属于 window 对象。window 对象是 BOM 的顶层（核心）对象。</li><li>document 是 window 对象里的一个子对象。document 是 DOM 的顶层。</li><li>document 代表整个网页，不代表任何 HTML 标签，但它是 html 节点的父节点。Document 对象使我们可以从脚本中对 HTML 页面中的所有元素进行访问。</li></ul><h3 id="Console-对象"><a href="#Console-对象" class="headerlink" title="Console 对象"></a>Console 对象</h3><p>JavaScript 原生中默认是没有 Console 对象，这是宿主对象（也就是游览器）提供的内置对象。</p><ul><li>方法：<ul><li><code>console.log( &quot;输出内容&quot; );</code><ul><li>将输出内容输出到控制台。</li></ul></li><li><code>console.warn( &quot;警告内容&quot; );</code><ul><li>将警告内容输出到控制台。</li></ul></li><li><code>console.error( &quot;错误内容&quot; );</code><ul><li>错误内容输出到控制台。</li></ul></li></ul></li></ul><h3 id="window-对象（BOM）"><a href="#window-对象（BOM）" class="headerlink" title="window 对象（BOM）"></a>window 对象（BOM）</h3><ul><li><p><code>alert( &quot;输出内容&quot; );</code></p><ul><li>alert 函数通过弹窗方式输出内容。</li></ul></li><li><p><code>confirm( &quot;输入内容&quot; );</code></p><ul><li>将输出内容进行逻辑判断。返回 boolean 类型。如果点击确定返回 true，点击取消返回 false。</li></ul></li><li><p>prompt() 方法用于显示可提示用户进行输入的对话框。</p><ul><li>语法：<code>prompt(text, defaultText);</code><ul><li>text<ul><li>可选。要在对话框中显示的纯文本（而不是 HTML 格式的文本）。</li></ul></li><li>defaultText<ul><li>可选。默认的输入文本。</li></ul></li></ul></li></ul></li><li><p><code>open( URL, name, features, replace );</code></p><ul><li>用于打开一个新的浏览器窗口或查找一个已命名的窗口。</li></ul></li><li><p><code>close();</code></p><ul><li>用于关闭浏览器窗口。</li></ul></li><li><p><code>setInterval( code, millisec );</code></p><ul><li>方法（定时器）可按照指定的周期（以毫秒计）来调用函数或计算表达式。</li><li>code<ul><li>必需。要调用的函数或要执行的代码串。</li></ul></li><li>millisec<ul><li>必须。周期性执行或调用 code 之间的时间间隔，以毫秒计。</li></ul></li></ul></li><li><p><code>clearInterval( id_of_setinterval )</code></p><ul><li>id_of_setinterval<ul><li>调用 setInterval() 函数时所获得的返回值，使用该返回标识符作为参数，可以取消该 setInterval() 所设定的定时执行操作。</li></ul></li></ul></li><li><p><code>setTimeout( code, milliseconds );</code></p><ul><li>调用一次性定时器。</li><li>code/function<ul><li>必需。要调用的函数后要执行的 JavaScript 代码串。</li></ul></li><li>milliseconds<ul><li>必需。在执行代码前需等待的毫秒数。</li></ul></li></ul></li><li><p><code>clearTimeout( id_of_settimeout );</code></p><ul><li>清除一次性定时器。</li><li>id_of_settimeout<ul><li>由 setTimeout() 返回的 ID 值。该值标识要取消的延迟执行代码块。</li></ul></li></ul></li><li><p>innerWidth 返回窗口的文档显示区的宽度。</p></li><li><p>innerHeight 返回窗口的文档显示区的高度。</p></li><li><p><code>window.print();</code></p><ul><li>控制打印机网页打印：</li></ul></li><li><p><code>requestAnimationFrame( callback );</code></p><ul><li>屏幕刷新前执行回调函数。</li><li>页面被隐藏或最小化时，回调函数不会执行。当页面被激活时，动画就从上次停留的地方继续执行。</li></ul></li><li><p><code>encodeURI( URIstring );</code></p><ul><li>可把字符串作为 URI 进行编码。</li><li>URIstring<ul><li>必需。一个字符串，含有 URI 或其他要编码的文本。</li></ul></li></ul></li><li><p><code>decodeURI( URIstring );</code></p><ul><li>可对 encodeURI() 函数编码过的 URI 进行解码。</li><li>URIstring<ul><li>必需。一个字符串，含有要解码的 URI 或其他要解码的文本。</li></ul></li></ul></li><li><p><code>getComputedStyle( element, [ pseudoElt ] );</code></p><ul><li>该方法返回一个对象，该对象在应用活动样式表并解析这些值可能包含的任何基本计算后，报告元素的所有 CSS 属性的值。单个 CSS 属性值通过对象提供的 API 或通过使用 CSS 属性名称进行索引来访问。</li></ul></li><li><p><code>postMessage( message, targetOrigin, [transfer] );</code></p><ul><li>postMessage() 可以安全地实现跨源通信。</li><li>message 将要发送到其他 window 的数据。它将会被结构化克隆算法序列化。这意味着你可以不受什么限制的将数据对象安全的传送给目标窗口而无需自己序列化。</li><li>targetOrigin 通过窗口的 origin 属性来指定哪些窗口能接收到消息事件，其值可以是字符串”*”（表示无限制）或者一个 URI。在发送消息的时候，如果目标窗口的协议、主机地址或端口这三者的任意一项不匹配 targetOrigin 提供的值，那么消息就不会被发送。</li><li>通过 message 事件产生的 event 对象获取 postMessage() 方法发送的数据。<ul><li>event.data<ul><li>从其他 window 中传递过来的对象。</li></ul></li></ul></li></ul></li></ul><h3 id="Location-对象（BOM）"><a href="#Location-对象（BOM）" class="headerlink" title="Location 对象（BOM）"></a>Location 对象（BOM）</h3><ul><li><p>href</p><ul><li>设置或返回完整的 URL。</li></ul></li><li><p>reload()</p><ul><li>刷新当前页面。</li></ul></li><li><p>hash</p><ul><li><p>hash 属性是一个可读可写的字符串，该字符串是 URL 的锚部分（从 ## 号开始的部分）。</p></li><li><p>设置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">location.hash = anchorname;</span><br></pre></td></tr></table></figure></li><li><p>读取：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(location.hash); // 读取结果为：#anchorname</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="Screen-对象（BOM）"><a href="#Screen-对象（BOM）" class="headerlink" title="Screen 对象（BOM）"></a>Screen 对象（BOM）</h3><ul><li>width<ul><li>返回显示器屏幕的宽度。</li></ul></li><li>height<ul><li>返回显示屏幕的高度。</li></ul></li></ul><h3 id="Navigator-对象（BOM）"><a href="#Navigator-对象（BOM）" class="headerlink" title="Navigator 对象（BOM）"></a>Navigator 对象（BOM）</h3><ul><li>userAgent<ul><li>返回由客户机发送服务器的 user-agent 头部的值。</li></ul></li><li><code>navigator.getUserMedia ( constraints, successCallback, errorCallback );</code><ul><li>获取摄像头</li></ul></li></ul><h3 id="URL-对象"><a href="#URL-对象" class="headerlink" title="URL 对象"></a>URL 对象</h3><ul><li><code>createObjectURL(blob);</code><ul><li>blob 参数是用来创建 URL 的 File 对象或者 Blob 对象。</li></ul></li></ul><h3 id="document-对象"><a href="#document-对象" class="headerlink" title="document 对象"></a>document 对象</h3><ul><li><code>getElementById( &quot;id&quot; );</code><ul><li>通过 id 属性获取 DOM 对象。返回一个对象。</li></ul></li><li><code>getElementsByClassName( &quot;class&quot; );</code><ul><li>通过 class 属性获取 DOM 对象，返回一个集合。</li></ul></li><li><code>getElementsByTagName( &quot;标签名&quot; );</code><ul><li>通过标签名获取 DOM 对象，返回一个集合。</li></ul></li><li><code>getElementsByName( &quot;name&quot; );</code><ul><li>通过 name 属性获取 DOM 对象，返回一个集合。</li></ul></li><li><code>createElement( &quot;标签&quot; );</code><ul><li>创建结点。</li></ul></li><li>documentElement<ul><li>对象是整个节点树的根节点 root，即&lt;html&gt; 标签；</li></ul></li><li>body<ul><li>获取身体，即&lt;body&gt; 标签。</li><li>body 的高度由网页的内容决定。获取内容的高度，就是获取 body 的高度（height）。</li></ul></li><li>title<ul><li>获取标题。</li></ul></li><li>compatMode<ul><li>其值为 CSS1Compat 对应标准模式（遵循 W3C 标准）。</li><li>其值为 BackCompat 对应混杂模式（按照浏览器标准）。</li></ul></li></ul><h3 id="核心-DOM"><a href="#核心-DOM" class="headerlink" title="核心 DOM"></a>核心 DOM</h3><ul><li><p>offsetWidth</p><ul><li>返回元素的宽度（包括元素宽度、内边距和边框）</li></ul></li><li><p>offsetHeight</p><ul><li>返回元素的高度（包括元素高度、内边距和边框）</li></ul></li><li><p>clientWidth</p><ul><li>返回元素的宽度（包括元素宽度、内边距，不包括边框）</li></ul></li><li><p>clientHeight</p><ul><li>返回元素的高度（包括元素高度、内边距，不包括边框）</li></ul></li><li><p>scrollWidth</p><ul><li>返回元素的宽度（包括元素宽度、内边距和溢出尺寸，不包括边框）</li></ul></li><li><p>scrollHeigh</p><ul><li>返回元素的高度（包括元素高度、内边距和溢出尺寸，不包括边框）</li></ul></li><li><p>offsetTop</p><ul><li>返回元素的上外缘到最近采用定位父元素内壁的距离，如果父元素中没有采用定位的，则是获取上外边缘到文档内壁的距离。</li></ul></li><li><p>offsetLeft</p><ul><li>此属性和 offsetTop 的原理一样。</li></ul></li><li><p>scrollTop</p><ul><li>滚动条距离最顶端的距离。</li></ul></li><li><p>scrollLeft</p><ul><li>滚动条距离最左边的距离。</li></ul></li><li><p>pageYOffset</p><ul><li>scrollTop 兼容性写法。</li></ul></li><li><p>pageXOffset</p><ul><li>scrollLeft 兼容性写法。</li></ul></li><li><p><code>querySelector( &quot;CSS 选择器&quot; );</code></p><ul><li>通过选择器获取第一个 DOM 对象。</li></ul></li><li><p><code>querySelectorAll( &quot;CSS 选择器&quot; );</code></p><ul><li>通过选择器返回所有 DOM 对象。</li></ul></li><li><p><code>element.addEventListener(event, function, useCapture)</code>用于向指定元素添加事件句柄。</p><ul><li>event<ul><li>必须。字符串，指定事件名。不要使用 “on” 前缀。</li></ul></li><li>function<ul><li>必须。指定要事件触发时执行的函数。</li></ul></li><li>useCapture<ul><li>可选。布尔值，指定事件是否在捕获或冒泡阶段执行。<ul><li>true<ul><li>事件句柄在捕获阶段执行。</li></ul></li><li>false<ul><li>默认。事件句柄在冒泡阶段执行。</li></ul></li></ul></li></ul></li><li>addEventListener() 添加相同事件不会覆盖已存在的事件。</li><li>如果浏览器不支持 addEventListener() 方法，可以使用 attachEvent() 方法替代。</li></ul></li><li><p><code>element.removeEventListener(event, function, useCapture)</code>移除由 addEventListener() 方法添加的事件句柄。</p><ul><li>event<ul><li>必须。要移除的事件名称。.</li></ul></li><li>function<ul><li>必须。指定要移除的函数。</li></ul></li><li>useCapture<ul><li>可选。布尔值，指定移除事件句柄的阶段。<ul><li>true<ul><li>在捕获阶段移除事件句柄。</li></ul></li><li>false<ul><li>默认。在冒泡阶段移除事件句柄。</li></ul></li></ul></li></ul></li><li>如果浏览器不支持 removeEventListener() 方法，你可以使用 detachEvent() 方法实现。</li></ul></li><li><p>parentNode</p><ul><li>获取父节点。</li></ul></li><li><p>nextSibling</p><ul><li>获取下一个兄弟结点。</li></ul></li><li><p>previousSibling</p><ul><li>获取上一个兄弟结点。</li></ul></li><li><p>firstChild</p><ul><li>获取第一个子节点。</li></ul></li><li><p>lastChild</p><ul><li>获取最后一个子节点。</li></ul></li><li><p>children</p><ul><li>获取所有一级结点。返回一个数组。</li></ul></li><li><p>childNodes</p><ul><li>获取所有子节点。包括文本节点和元素节点。</li></ul></li><li><p>nodeType</p><ul><li>返回元素的节点类型。</li><li>1 表示的是元素结点。2 表示的是属性结点。3 表示的是文本结点。</li><li>节点类型<ul><li>元素节点：拥有一对开闭合标签的元素整体，例如：<code>&lt;ul&gt;...&lt;/ul&gt;</code>。</li><li>属性节点：元素节点的属性。</li><li>文本节点：用于呈现文本的部分。</li></ul></li></ul></li><li><p>tagName</p><ul><li>返回元素的标签名。</li></ul></li><li><p>nodeName</p><ul><li>返回元素的标签名。</li></ul></li><li><p><code>appendChild( 结点 );</code></p><ul><li>将传入结点插入到自己的子节点的末尾。</li></ul></li><li><p><code>insertBefore( 结点 1, 结点 2 );</code></p><ul><li>将结点 1 插入到自己的子结点 2 之前。</li></ul></li><li><p>remove();</p><ul><li>删除本结点。</li></ul></li><li><p><code>removeChild( 结点 );</code></p><ul><li>删除传入的子节点。</li></ul></li><li><p><code>cloneNode( boolean );</code></p><ul><li>复制本结点并返回。boolean 为 true 深层拷贝，如果为 false，只复制结点本身。</li></ul></li><li><p><code>getAttribute( &quot;结点元素属性&quot; );</code></p><ul><li>获取结点元素属性的内容。</li><li>结点。属性<strong>只能</strong>访问已有的属性。</li></ul></li><li><p><code>setAttribute( &quot;属性名称&quot;, &quot;属性值&quot;);</code></p><ul><li>设置属性。访问的属性名称不存在则自动创建。</li></ul></li><li><p><code>removeAttribute( &quot;元素名称&quot; );</code></p><ul><li>删除元素属性。</li></ul></li><li><p>innerHTML</p><ul><li>获取标签中的所有标签和文本。</li></ul></li><li><p>innerText</p><ul><li>获取标签中所有的文本。</li></ul></li><li><p>textContent</p><ul><li>获取结点的文本内容。</li><li>textContent 和 innerText 的区别：<ul><li>textContent 能够获取元素的所有子节点上的文本，不管这个节点是否呈现；而 innerText 只返回呈现到页面上的文本。</li></ul></li></ul></li><li><p>className</p><ul><li>获取标签的 class 属性。</li></ul></li><li><p>style</p><ul><li>代表一个单独的样式声明。</li></ul></li><li><p>offsetParent</p><ul><li>返回当前对象的父级（带有定位）盒子。可能是父亲，也可能是爷爷。</li></ul></li></ul><h3 id="img-对象"><a href="#img-对象" class="headerlink" title="img 对象"></a>img 对象</h3><ul><li>complete<ul><li>返回浏览器是否已完成对图像的加载。</li><li>如果加载完成，则返回 true，否则返回 fasle。</li><li>如何检测 background-image(backgroundImage) 属性是否加载完毕？<ul><li>可以暂时把图片 URL 赋值给 Image 对象的 src 属性。</li><li>再通过 Image（img）对象的 complete 属性判断是否加载完毕。</li></ul></li></ul></li></ul><h3 id="input-对象"><a href="#input-对象" class="headerlink" title="input 对象"></a>input 对象</h3><ul><li>value<ul><li>获取标签 value 属性。</li></ul></li></ul><h3 id="iframe-frame-对象"><a href="#iframe-frame-对象" class="headerlink" title="iframe/frame 对象"></a>iframe/frame 对象</h3><ul><li>contentDocument 属性能够以 Document 对象来返回 iframe 中的文档。</li><li>关于 contentWindow 和 contentDocument<ul><li>使用这两个对象，父子页面必须同源。</li><li>contentWindow 是用来获取子窗口的 window 对象。</li><li>contentDocument 是用来获取子窗口的 document 对象的。</li><li>contentWindow 兼容各个浏览器。</li><li>contentDocument 支持 Firefox 和大于 ie8 的 ie 浏览器。</li></ul></li></ul><h2 id="canvas"><a href="#canvas" class="headerlink" title="canvas"></a>canvas</h2><ul><li><code>getContext(contextType[, contextAttributes]);</code><ul><li>返回 canvas 的上下文，不合法返回 null。</li><li>contextType 上下文类型：<ul><li>“2d”建立一个 CanvasRenderingContext2D 二维渲染上下文。</li><li>“webgl”创建一个 WebGLRenderingContext 三维渲染上下文对象。</li><li>“webgl2”创建一个 WebGL2RenderingContext 三维渲染上下文对象。</li></ul></li><li>设置路径：<ul><li>beginPath()<ul><li>重置路径。</li></ul></li><li>closePath()<ul><li>闭合路径。</li></ul></li><li><code>moveTo(x, y)</code><ul><li>移动到指定的坐标 x 以及 y 上。</li></ul></li><li><code>lineTo(x, y)</code><ul><li>绘制一条从当前位置到指定 x 以及 y 位置的直线。</li></ul></li><li><code>quadraticCurveTo(cp1x, cp1y, x, y)</code><ul><li>绘制二次贝塞尔曲线，cp1x,cp1y 为一个控制点，x,y 为结束点。</li></ul></li><li><code>bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y)</code><ul><li>绘制三次贝塞尔曲线，cp1x,cp1y 为控制点一，cp2x,cp2y 为控制点二，x,y 为结束点。</li></ul></li><li><code>rect(x, y, width, height)</code><ul><li>绘制一个左上角坐标为（x,y），宽高为 width 以及 height 的矩形。</li></ul></li><li><code>arc(x, y, radius, startAngle, endAngle, anticlockwise)</code><ul><li>画一个以（x,y）为圆心的以 radius 为半径的圆弧（圆），从 startAngle 开始到 endAngle 结束，按照 anticlockwise 给定的方向（默认为顺时针）来生成。</li><li>Math.PI（圆周率）为 180 度。</li></ul></li></ul></li><li>绘制和填充方法：<ul><li>stroke()<ul><li>通过线条来绘制图形轮廓。</li></ul></li><li>fill()<ul><li>通过填充路径的内容区域生成实心的图形。</li></ul></li><li><code>strokeRect(x, y, width, height)</code><ul><li>绘制一个矩形的边框。</li></ul></li><li><code>fillRect(x, y, width, height)</code><ul><li>绘制一个填充的矩形。</li></ul></li><li><code>clearRect(x, y, width, height)</code><ul><li>清除指定矩形区域，让清除部分完全透明。</li></ul></li></ul></li><li>设置样式：<ul><li>fillStyle<ul><li>图形的填充颜色。</li></ul></li><li>strokeStyle<ul><li>图形轮廓的颜色。</li></ul></li><li>globalAlpha<ul><li>图形的透明度，有效值 0-1。</li></ul></li><li>lineWidth<ul><li>设置线条宽度。</li></ul></li><li>lineCap<ul><li>设置线条末端样式。</li></ul></li><li>lineJoin<ul><li>设定线条与线条间接合处的样式。</li></ul></li><li>miterLimit<ul><li>限制当两条线相交时交接处最大长度；所谓交接处长度（斜接长度）是指线条交接处内角顶点到外角顶点的长度。</li></ul></li><li>setLineDash(segments)<ul><li>接受一个 Array 数组。一组描述交替绘制线段长度和间距长度的数字。如果数组元素的数量是奇数，数组的元素会被复制并重复。</li></ul></li></ul></li></ul></li></ul><h2 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h2><p>请求仅支持协议方案：http, data, chrome, chrome-extension, https。</p><h3 id="请求的类型"><a href="#请求的类型" class="headerlink" title="请求的类型"></a>请求的类型</h3><p>POST 请求添加数据。</p><p>DELETE 请求删除数据。</p><p>PUT 请求更新数据。</p><p>GET 请求获取数据。</p><h3 id="请求的发送方式"><a href="#请求的发送方式" class="headerlink" title="请求的发送方式"></a>请求的发送方式</h3><ol><li>通过浏览器的地址栏</li><li>通过 html 当中的 form 表单</li><li>通过 a 标签的 href 属性</li><li>src 属性</li></ol><h3 id="通过-AJAX-发送请求-XMLHttpRequest"><a href="#通过-AJAX-发送请求-XMLHttpRequest" class="headerlink" title="通过 AJAX 发送请求 (XMLHttpRequest)"></a>通过 AJAX 发送请求 (XMLHttpRequest)</h3><p>AJAX 可以发送网络请求或请求本地文件。</p><ul><li>XMLHttpRequest 对象<ul><li>readyState<ul><li>HTTP 请求的状态。<ul><li>4 表示 HTTP 响应已经完全接收。</li></ul></li><li>readyState 小于 3 的时候读取 status 属性会导致一个异常。</li></ul></li><li>status<ul><li>服务器返回的 HTTP 状态代码。<ul><li>200 表示成功。</li></ul></li></ul></li><li><code>open( method, url, async )</code><ul><li>初始化 HTTP 请求参数，但是并不发送请求。</li><li>method<ul><li>请求的类型；GET 或 POST</li><li>请求类型为 POST，必须设置请求头部的响应类型为 application/x-www-form-urlencoded。</li></ul></li><li>url<ul><li>该文件可以是任何类型的文件，比如 .txt 和 .xml，或者服务器脚本文件，比如 .asp 和 .php。</li></ul></li><li>async<ul><li>true（异步，默认）或 false（同步）。<ul><li>同步和异步的区别？<ul><li>同步：send 方法要接收到服务器返回的数据后才返回。</li><li>异步：send 调用后立即返回，服务器返回的数据在 onreadystatechange 设置的异步回调里面进行读取。</li></ul></li></ul></li></ul></li></ul></li><li>send()<ul><li>发送 HTTP 请求，使用传递给 open() 方法的参数，<strong>以及传递给该方法的可选请求体</strong>。</li></ul></li><li>responseText<ul><li>获得字符串形式的响应数据。</li></ul></li><li>responseXML<ul><li>获得 XML 形式的响应数据（document 对象）。</li></ul></li><li>abort()<ul><li>取消当前响应，关闭连接并且结束任何未解决的网络活动。</li></ul></li><li>onreadystatechange 事件<ul><li>每次 readyState 属性改变的时候触发事件。当 readyState 为 3 时可能调用多次。</li></ul></li></ul></li></ul><h3 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h3><p>JSON 有两种结构：对象和数组。</p><p>数据在键值对中，数据由逗号分隔，花括号保存对象，方括号保存数组。</p><p>JS 当中对象键值分号可不要，JSON 数据键值分号不可省略。</p><ul><li><code>JSON.parse( jsonstr );</code><ul><li>可以将 json 字符串转换成 json 对象。</li></ul></li><li><code>JSON.stringify( jsonobj );</code><ul><li>可以将 json 对象转换成 json 字符串。</li></ul></li></ul><p>低版本的 IE 浏览器不支持原生方法转换 JSON 对象，可以借助 json2.js（JQuery 插件） 解决。</p><p>可以通过 AJAX 请求服务器的静态 JSON 文件减少服务器压力，不一定要请求接口，获取动态数据。</p><h3 id="IE-浏览器-AJAX-缓存"><a href="#IE-浏览器-AJAX-缓存" class="headerlink" title="IE 浏览器 AJAX 缓存"></a>IE 浏览器 AJAX 缓存</h3><p>IE 会针对 ajax 相同的请求 URL 进行缓存，只有第一次会发送请求到服务端，如果继续发送 AJAX 请求，IE 浏览器会直接在缓存中读取数据并返回。</p><ul><li>解决办法：在 URL 上添加一个随机参数即可解决。</li></ul><h3 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h3><p><strong>浏览器</strong>对于 javascript 的同源策略的限制，例如 a.cn 下面的 js 不能调用 b.cn 中的 js, 对象或数据（因为 a.cn 和 b.cn 是不同域）, 所以跨域就出现了。</p><ul><li>同源策略：请求的 url 地址，必须与浏览器上的 url 地址处于同域上，也就是域名，端口，协议相同。</li><li>跨域是浏览器禁止的，服务端并不禁止跨域 。</li></ul><h4 id="跨域请求"><a href="#跨域请求" class="headerlink" title="跨域请求"></a>跨域请求</h4><p>凡是拥有 src 属性的标签都有跨域能力，如：&lt;script&gt;、 &lt;img&gt;、 &lt;iframe&gt;。</p><ul><li>JSONP 原理就是通过 script 标签发送请求（参数为方法名），服务端通过拼接字符串拼接成 <code>方法名 (JSON 数据）</code> 的形式返回前端，前端立马执行返回方法，方法里做逻辑处理。</li></ul><p>服务器响应头设置 CORS：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//允许所有域名的脚本访问该资源。</span><br><span class="line">Access-Control-Allow-Origin:*</span><br><span class="line"></span><br><span class="line">//允许特定的域名访问。</span><br><span class="line">Access-Control-Allow-Origin:http://www.phpddt.com.com</span><br></pre></td></tr></table></figure><p>通过代理服务器解决跨域（nginx 或 webpack 中的 proxyTable）。</p><h2 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h2><p>Cookie 是浏览器访问服务器后，服务器（通过请求头）传给浏览器的一段数据。</p><p>浏览器需要保存这段数据（保存到用户电脑），不得轻易删除。</p><p>此后每次浏览器访问该服务器，都必须带上这段数据。</p><p>当浏览器从服务器上请求 web 页面时， 属于该页面的 cookie 会被添加到该请求中。服务端通过这种方式来获取用户的信息。</p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>网络早期最大的问题之一是如何管理状态。简而言之，服务器无法知道两个请求是否来自同一个浏览器。当时最简单的方法是在请求时，在页面中插入一些参数，并在下一个请求中传回参数。</p><p>Cookies 是一种能够让网站服务器把少量数据储存到客户端的硬盘或内存，或是从客户端的硬盘读取数据的一种技术。</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>每次网页发送 http 请求时，浏览器会先检查是否有相应的 cookie，有则自动添加在 request header 中的 cookie 字段中。</p><p>cookie 的存储是以域名形式进行区分的，不同的域下存储的 cookie 是独立的。</p><p>我们可以设置 cookie 生效的域（当前设置 cookie 所在域的子域）。</p><p>一个域名下存放的 cookie 的个数是有限制的，不同浏览器存放的个数不一样，一般为 20 个。</p><p>每个 cookie 存放的内容大小也是有限制的，不同的浏览器存放大小不一样，一般为 4KB。</p><p>cookie 也可以设置过期的时间，默认是会话结束的时候，当时间到期自动销毁。</p><ul><li>设置了过期时间 cookie 就会存储在硬盘里面。</li><li>没有设置过期时间（expires） cookie 就会存储在内存里面。</li></ul><h3 id="cookie-参数"><a href="#cookie-参数" class="headerlink" title="cookie 参数"></a>cookie 参数</h3><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">key</td><td align="left">必需。规定 cookie 的名称。</td></tr><tr><td align="left">value</td><td align="left">必需。规定 cookie 的值。</td></tr><tr><td align="left">expires</td><td align="left">可选。规定 cookie 的有效期。</td></tr><tr><td align="left">path</td><td align="left">可选。规定 cookie 的服务器路径。</td></tr><tr><td align="left">domain</td><td align="left">可选。规定 cookie 的域名。</td></tr><tr><td align="left">secure</td><td align="left">可选。规定是否通过安全的 HTTPS 连接来传输 cookie。</td></tr></tbody></table><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>设置 cookie</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.cookie = <span class="string">'名字=值'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// domain 为 cookie 生效域</span></span><br><span class="line"><span class="built_in">document</span>.cookie = <span class="string">'username=cfangxu;domain=baike.baidu.com'</span>;</span><br></pre></td></tr></table></figure><ul><li>cookie 存值时不能一次性设置多个值。<ul><li>例如：<code>document.cookie = &#39;名字 1=值；名字 2=值&#39;;</code>。</li></ul></li></ul><p>读取</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="built_in">document</span>.cookie;</span><br></pre></td></tr></table></figure><p>修改</p><ul><li>修改 cookie 类似于创建 cookie。</li><li>cookie 的 key 值是唯一的。</li></ul><p>删除</p><ul><li>设置 expires 参数为以前的时间即可。</li></ul><h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><p>本地设置的 cookie 是无法保存的，cookie 必须依靠 http 协议（cookie 就是一个请求头字段）。</p><p>cookie 是无法跨域携带的，必须设置 withCredentials 属性为 true，允许 ajax 请求携带 cookie。</p><h2 id="本地存储"><a href="#本地存储" class="headerlink" title="本地存储"></a>本地存储</h2><h3 id="localStorage-对象（BOM）"><a href="#localStorage-对象（BOM）" class="headerlink" title="localStorage 对象（BOM）"></a>localStorage 对象（BOM）</h3><p>localStorage 中一般浏览器支持的是 5M 大小，可以实现不同网页之间传输数据。</p><p>localStorage 保存的数据除非被清除，否则永久保存。</p><p>仅在客户端（即浏览器）中保存，不参与和服务器的通信。</p><h3 id="sessionStorage-对象（BOM）"><a href="#sessionStorage-对象（BOM）" class="headerlink" title="sessionStorage 对象（BOM）"></a>sessionStorage 对象（BOM）</h3><p>sessionStorage 与 localStorage 的接口类似，但保存数据的生命周期与 localStorage 不同。</p><p>当页面关闭后，sessionStorage 中的数据就会被清空。</p><p>仅在客户端（即浏览器）中保存，不参与和服务器的通信。</p><h2 id="IndexedDB"><a href="#IndexedDB" class="headerlink" title="IndexedDB"></a>IndexedDB</h2><p>正在努力编写中。..</p><h2 id="Base64"><a href="#Base64" class="headerlink" title="Base64"></a>Base64</h2><p>Base64 的索引表，字符选用了 “A-Z、a-z、0-9、+、/“ 64 个可打印字符，标准的 Base64 协议规定。</p><p>Base64 的编码步骤：</p><ol><li>将待转换的字符串每三个字节分为一组，每个字节占 8bit，那么共有 24 个二进制位。</li><li>将上面的 24 个二进制位每 6 个一组，共分为 4 组。</li><li>在每组前面添加两个 0，每组由 6 个变为 8 个二进制位，总共 32 个二进制位，即四个字节。<ul><li>位数不足，用 0 补齐。没有数据则用 “=” 补上。</li></ul></li><li>根据 Base64 编码对照表获得对应的值。</li></ol><p>大多数编码都是由字符串转化成二进制的过程，而 Base64 的编码则是从二进制转换为字符串。</p><p>Base64 编码主要用在传输、存储、表示二进制领域，不能算得上加密，只是无法直接看到明文。</p><h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><ul><li><p>URL 编码</p><ul><li><p>URL 编码，以便发送给浏览器。有效的 URL 编码中不能包含某些字符，例如空格。用特殊的 UTF-8 编码替换所有无效的字符，从而让浏览器能够接收。URL 编码是无法直接识别的，必须解码。</p></li><li><p>encodeURLComponent 函数可把字符串进行 URL 编码。</p></li><li><p>decodeURLComponent 函数可把 URL 编码的字符串进行解码。</p></li></ul></li><li><p>Data URLs，即前缀为 data: 协议的的 URL，其允许内容创建者向文档中嵌入小文件。</p><ul><li>结构：Data URLs 由四个部分组成：前缀 (data:)、指示数据类型的 MIME 类型、如果非文本则为可选的 base64 标记、数据本身。</li><li>语法：<code>data:[&lt;mediatype&gt;][;base64],&lt;data&gt;</code><ul><li>mediatype 是个 MIME 类型的字符串，例如 “image/jpeg” 表示 JPEG 图像文件。如果被省略，则默认值为 text/plain;charset=US-ASCII。</li></ul></li></ul></li><li><p>Blob URL</p><ul><li>URL.createObjectURL() 方法会根据传入的参数创建一个指向该参数对象的 URL。</li></ul></li></ul><h2 id="Blob-对象"><a href="#Blob-对象" class="headerlink" title="Blob 对象"></a>Blob 对象</h2><p>Blob 对象表示一个不可变、原始数据的类文件对象。File 接口基于 Blob，继承了 blob 的功能并将其扩展使其支持用户系统上的文件。</p><p>Blob 对象是一个二进制对象，可以存放二进制数据，还可以设置这个数据的 MINE 类型。</p><h2 id="图片预览"><a href="#图片预览" class="headerlink" title="图片预览"></a>图片预览</h2><ul><li><p>Files 对象</p><ul><li>在表单元素上&lt;input type=”file”/&gt;，可以选择一个或多个文件，通过获取文件元素对象的集合 files，来操作每一个对象 files[i]；每一个 file 对象对应一个文件。</li><li><code>file.name</code><ul><li>获取本地文件系统的文件名。</li></ul></li><li>file.size<ul><li>文件的字节大小。</li></ul></li><li>file.type<ul><li>字符串类型，文件的 MIME 类型。</li></ul></li><li>file.lastModifiedDate<ul><li>文件的最后修改时间。</li></ul></li><li>objectURL = URL.createObjectURL(blob);<ul><li>blob 参数是用来创建 URL 的 File 对象或者 Blob 对象。生成的 blob url 可以被 img 等标签使用。</li></ul></li><li>虽然 file 的 value 不能设为有字符的值，但是可以设置为空值。</li></ul></li><li><p>FileReader 对象</p><ul><li><p>FileReader 构造函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var reader = new FileReader();</span><br></pre></td></tr></table></figure></li><li><p>FileReader 对象中的方法</p><ul><li>readAsDataURL(file)<ul><li>读取文件内容，结果用 data:url 的字符串形式保存到 result 属性中。result 属性中的值可以直接赋予 img 对象的 src 属性。</li></ul></li></ul></li><li><p>FileReader 对象中的事件</p><ul><li>onloadend<ul><li>该事件在读取操作结束时（要么成功，要么失败）触发。</li></ul></li></ul></li></ul></li></ul><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><h3 id="定义正则"><a href="#定义正则" class="headerlink" title="定义正则"></a>定义正则</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var re = new RegExp( &quot;正则表达式&quot; );</span><br><span class="line">var re = /正则表达式/; //简写方法。</span><br></pre></td></tr></table></figure><table><thead><tr><th align="left">特殊字符</th><th align="left">解释</th></tr></thead><tbody><tr><td align="left">^</td><td align="left">为匹配输入字符串的开始位置。</td></tr><tr><td align="left">$</td><td align="left">为匹配输入字符串的结束位置。</td></tr></tbody></table><p>要匹配特殊字符，需要进行转义。特殊字符前加反斜杠<code>\</code>。</p><table><thead><tr><th align="left">限定符</th><th align="left">解释</th></tr></thead><tbody><tr><td align="left"><code>?</code></td><td align="left">问号代表前面的字符最多只可以出现一次。</td></tr><tr><td align="left"><code>*</code></td><td align="left">号代表字符可以不出现，也可以出现一次或者多次。</td></tr><tr><td align="left"><code>+</code></td><td align="left">号代表前面的字符必须至少出现一次（1 次或多次）。</td></tr><tr><td align="left"><code>{n}</code></td><td align="left">n 是一个非负整数。匹配确定的 n 次。</td></tr><tr><td align="left"><code>{n,}</code></td><td align="left">n 是一个非负整数。至少匹配 n 次。</td></tr><tr><td align="left"><code>{n,m}</code></td><td align="left">m 和 n 均为非负整数，其中 n &lt;= m。最少匹配 n 次且最多匹配 m 次。</td></tr><tr><td align="left"><code>()</code></td><td align="left">标记一个子表达式的开始和结束位置。例如：(es)，es 字符串算一个子表达式。</td></tr><tr><td align="left"><code>.</code></td><td align="left">匹配除换行符 \n 之外的任何单字符。例如：.* 匹配任意字符。</td></tr><tr><td align="left"><code>\w</code></td><td align="left">匹配字母、数字、下划线</td></tr><tr><td align="left"><code>[</code></td><td align="left">标记一个范围表达式的开始。</td></tr><tr><td align="left"><code>{</code></td><td align="left">标记限定符表达式的开始。</td></tr><tr><td align="left">|</td><td align="left">指明两项之间的一个选择。</td></tr><tr><td align="left"><code>\</code></td><td align="left">将下一个字符标记为转义字符。</td></tr></tbody></table><p>限定符用来指定正则表达式的一个给定组件必须要出现多少次才能满足匹配。</p><h2 id="Web-Workers"><a href="#Web-Workers" class="headerlink" title="Web Workers"></a>Web Workers</h2><p>web worker 是运行在后台的 JavaScript，不会影响页面的性能。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sat Sep 24 2022 00:07:49 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;本文主要介绍 JavaScript 中事件的相关概念以及常用事件。&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端" scheme="https://zero3737.gitee.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="https://zero3737.gitee.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="教程" scheme="https://zero3737.gitee.io/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="JavaScript" scheme="https://zero3737.gitee.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>实例化对象（new）的过程</title>
    <link href="https://zero3737.gitee.io/posts/514ba138/"/>
    <id>https://zero3737.gitee.io/posts/514ba138/</id>
    <published>2020-04-23T18:14:05.000Z</published>
    <updated>2022-09-17T18:37:23.600Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Sep 24 2022 00:07:49 GMT+0800 (GMT+08:00) --><p>本文介绍 JavaScript 中实例化（new）一个对象的过程。</p><a id="more"></a><hr><h2 id="实例化对象（new）的过程"><a href="#实例化对象（new）的过程" class="headerlink" title="实例化对象（new）的过程"></a>实例化对象（new）的过程</h2><ol><li><p>创建空对象。</p></li><li><p>设置新对象的 constructor 属性为构造函数的名称，设置新对象的 <code>__proto__</code> 属性指向构造函数的 prototype 对象。</p></li><li><p>使用新对象调用函数，函数中的 this 被指向新实例对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person.call(obj); <span class="comment">// 此时 obj 没有名字。</span></span><br></pre></td></tr></table></figure></li><li><p>将初始化完毕的新对象地址，保存到等号左边的变量中。</p></li></ol><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sat Sep 24 2022 00:07:49 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;本文介绍 JavaScript 中实例化（new）一个对象的过程。&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端" scheme="https://zero3737.gitee.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="https://zero3737.gitee.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="https://zero3737.gitee.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 中的原型链和函数原型</title>
    <link href="https://zero3737.gitee.io/posts/77987eec/"/>
    <id>https://zero3737.gitee.io/posts/77987eec/</id>
    <published>2020-04-23T17:43:37.000Z</published>
    <updated>2022-09-17T18:37:23.594Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Sep 24 2022 00:07:49 GMT+0800 (GMT+08:00) --><p>本文主要对 JavaScript 中的原型链和函数原型进行简单说明。</p><a id="more"></a><hr><h2 id="函数原型及原型链"><a href="#函数原型及原型链" class="headerlink" title="函数原型及原型链"></a>函数原型及原型链</h2><p>JS 创建对象的时候有一个 <code>__proto__</code> 内置属性，用于指向构造函数的原型对象 prototype，prototype 相当于特定类型所有实例都可以访问到的一个公共容器。</p><p>prototype 对象包含 constructor 属性，constructor 属性指向该构造函数。</p><p>Function 是一个构造器，能创建 Function 类型的对象，即 JS 中每个函数实际上都是 Function 类型的对象；而通过构造函数实例化的都是普通对象，普通对象没有 propotype ，但是有 <code>__proto__</code> 属性。</p><h2 id="原型链指向"><a href="#原型链指向" class="headerlink" title="原型链指向"></a>原型链指向</h2><ol><li>实例对象 <code>__proto__</code> 指向构造函数的原型。</li><li>构造函数 <code>__proto__</code> 指向 Function 对象的原型。</li><li>Function 对象的 <code>__proto__</code> 指向自己的原型。</li><li>所有 prototype 对象内置 <code>__proto__</code> 属性，<code>__proto__</code> 指向 Object 对象。</li><li>Object 的 <code>__proto__</code> 指向 null 。</li></ol><p>注意：<code>{}</code> 创建的对象 <code>__proto__</code> 直接指向 Object 的 原型。</p><h2 id="函数原型特点"><a href="#函数原型特点" class="headerlink" title="函数原型特点"></a>函数原型特点</h2><p>当函数对象本身的属性或方法与原型的属性或方法同名的时，默认调用的是函数对象本身的属性或方法，通过原型增加的属性或方法的确是存在的，函数对象本身的属性或方法的优先级要高于原型的属性或方法。</p><p>改变构造函数的 prototype 指向（引用），实例化对象的 <code>__proto__</code> 指向的 prototype 也会随之改变，因为实例化对象的 <code>__proto__</code> 指向构造函数的 prototype。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sat Sep 24 2022 00:07:49 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;本文主要对 JavaScript 中的原型链和函数原型进行简单说明。&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端" scheme="https://zero3737.gitee.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="https://zero3737.gitee.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="https://zero3737.gitee.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>for…in 遍历对象中的属性</title>
    <link href="https://zero3737.gitee.io/posts/fed4be0c/"/>
    <id>https://zero3737.gitee.io/posts/fed4be0c/</id>
    <published>2020-04-23T10:30:15.000Z</published>
    <updated>2022-09-17T18:37:23.604Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Sep 24 2022 00:07:49 GMT+0800 (GMT+08:00) --><h2 id="for…in"><a href="#for…in" class="headerlink" title="for…in"></a>for…in</h2><p>通过 for…in 遍历 obj 中的键值对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log( key );</span><br><span class="line">    <span class="built_in">console</span>.log( obj[key] );</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sat Sep 24 2022 00:07:49 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;for…in&quot;&gt;&lt;a href=&quot;#for…in&quot; class=&quot;headerlink&quot; title=&quot;for…in&quot;&gt;&lt;/a&gt;for…in&lt;/h2&gt;&lt;p&gt;通过 for…in 遍历 obj 中的键值对象：&lt;/p&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; key &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; obj) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log( key );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log( obj[key] );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="前端" scheme="https://zero3737.gitee.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="https://zero3737.gitee.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="https://zero3737.gitee.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>缓动动画公式</title>
    <link href="https://zero3737.gitee.io/posts/e7f867ee/"/>
    <id>https://zero3737.gitee.io/posts/e7f867ee/</id>
    <published>2020-04-21T10:00:18.000Z</published>
    <updated>2020-04-21T17:52:38.373Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Sep 24 2022 00:07:49 GMT+0800 (GMT+08:00) --><p>本文贴出缓动动画公式。</p><a id="more"></a><hr><h2 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h2><p>起始位置 += （结束位置 – 起始位置） * 缓动系数</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sat Sep 24 2022 00:07:49 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;本文贴出缓动动画公式。&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端" scheme="https://zero3737.gitee.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="https://zero3737.gitee.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="算法" scheme="https://zero3737.gitee.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>序列化与反序列</title>
    <link href="https://zero3737.gitee.io/posts/c88857d0/"/>
    <id>https://zero3737.gitee.io/posts/c88857d0/</id>
    <published>2020-04-21T09:53:16.000Z</published>
    <updated>2020-04-21T17:52:38.376Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Sep 24 2022 00:07:49 GMT+0800 (GMT+08:00) --><p>本文主要对序列化与反序列化概念进行说明。</p><a id="more"></a><hr><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>序列化是将对象的状态信息转换为可以存储或传输的形式的过程。在序列化期间，对象将其当前状态写入到临时或持久性存储区。以后，可以通过从存储区中读取或反序列化对象的状态，重新创建该对象。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sat Sep 24 2022 00:07:49 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;本文主要对序列化与反序列化概念进行说明。&lt;/p&gt;
    
    </summary>
    
    
      <category term="概念" scheme="https://zero3737.gitee.io/categories/%E6%A6%82%E5%BF%B5/"/>
    
    
      <category term="概念" scheme="https://zero3737.gitee.io/tags/%E6%A6%82%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>ECMAScript 6(ES6)</title>
    <link href="https://zero3737.gitee.io/posts/d0cad05d/"/>
    <id>https://zero3737.gitee.io/posts/d0cad05d/</id>
    <published>2020-04-21T07:50:30.000Z</published>
    <updated>2020-04-21T17:52:38.369Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Sep 24 2022 00:07:49 GMT+0800 (GMT+08:00) --><p>本文主要介绍 JavaScript 中 ES6 新特性。</p><a id="more"></a><hr><h2 id="let"><a href="#let" class="headerlink" title="let"></a>let</h2><h3 id="let-和-var-比较"><a href="#let-和-var-比较" class="headerlink" title="let 和 var 比较"></a>let 和 var 比较</h3><ul><li>var 定义变量在 function 代码块中定义，生命周期为局部的。在其他代码块中定义，声明周期为全局的。</li><li>let 定义变量，在代码块中定义，生命周期直到整个代码块执行结束。</li><li>var 在 function 代码块定义变量前访问变量，会变量提升。</li><li>let 定义变量前访问变量会报错。</li><li>var 可以重复定义变量（变量覆盖）。</li><li>let 不可以变量覆盖。</li></ul><h3 id="let-示例"><a href="#let-示例" class="headerlink" title="let 示例"></a>let 示例</h3><p>for 循环小括号中是父级作用域，花括号是小括号子作用域。即花括号可以访问小括号的变量，而小括号不能访问花括号中的变量。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    a[i] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line">a[<span class="number">6</span>](); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure><p>let 声明的变量仅在块级作用域有效，所以这里的 i 只在本轮循环有效果，每次循环的 i 其实都是一个新的变量。function 访问的变量通过作用域链访问最近的变量（如果同名）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [];</span><br><span class="line"><span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> j = i; <span class="comment">//j 为临时变量保存 i 值。</span></span><br><span class="line">    arr[j] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(j);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line">i++;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> j = i;</span><br><span class="line">    arr[j] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(j);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line">i++;</span><br><span class="line">arr[<span class="number">0</span>](); <span class="comment">//0</span></span><br><span class="line">arr[<span class="number">1</span>](); <span class="comment">//1</span></span><br></pre></td></tr></table></figure><p>作用域链：在当前作用域中没有查到值，就会向上级作用域去查，直到查到全局作用域，这么一个查找过程形成的链条就叫做作用域链。</p><h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><p>const 保证变量指向的内存地址所保存的数据不允许改动。对于简单类型（数值 number、 字符串 string、 布尔值 boolean）, 值就保存在变量指向的那个内存地址，因此 const 声明的简单类型变量等同于常量。而复杂类型（对象 object，数组 array，函数 function），变量指向的内存地址其实是保存了一个指向实际数据的指针，所以 const 只能保证指针是固定的，至于指针指向的数据结构变不变就无法控制了。</p><p>let 与 const 的区别：</p><ul><li>let 与 const 都是只在声明所在的块级作用域内有效。</li><li>let 声明的变量可以改变，值和类型都可以改变，没有限制。</li><li>const 声明的变量不得改变值，这意味着，const 一旦声明变量，就必须立即初始化，不能留到以后赋值。</li></ul><p>注意：let 和 const 不能混合使用。</p><h2 id="解构"><a href="#解构" class="headerlink" title="解构"></a>解构</h2><p>在解构中，有下面两部分参与：</p><ul><li>解构的源，解构赋值表达式的右边部分。</li><li>解构的目标，解构赋值表达式的左边部分。</li></ul><p>解构赋值语法是一种 JavaScript 表达式用来将数组中的值或对象中的属性取出来区分为不同变量。</p><h3 id="数组解构"><a href="#数组解构" class="headerlink" title="数组解构"></a>数组解构</h3><p>基本用法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, b, c] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure><p>可嵌套</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, [[b], c]] = [<span class="number">1</span>, [[<span class="number">2</span>], <span class="number">3</span>]];</span><br></pre></td></tr></table></figure><p>可忽略</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, , b] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]; <span class="comment">// a = 1 b = 3</span></span><br></pre></td></tr></table></figure><p>剩余运算符</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, ...b] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]; <span class="comment">// a = 1 b = [2, 3]</span></span><br></pre></td></tr></table></figure><p>解构实现 Iterator 接口的对象（例如：字符串对象）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, b, c, d, e] = <span class="string">'hello'</span>; <span class="comment">// a = 'h' b = 'e' c = 'l' d = 'l' e = 'o'</span></span><br></pre></td></tr></table></figure><p>解构默认值，当解构模式有匹配结果，且匹配结果是 undefined 时，会触发默认值作为返回结果。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a = <span class="number">2</span>] = [<span class="literal">undefined</span>];      <span class="comment">// a = 2</span></span><br><span class="line"><span class="keyword">let</span> [a = <span class="number">3</span>, b = a] = [];        <span class="comment">// a = 3, b = 3</span></span><br><span class="line"><span class="keyword">let</span> [a = <span class="number">3</span>, b = a] = [<span class="number">1</span>];       <span class="comment">// a = 1, b = 1</span></span><br><span class="line"><span class="keyword">let</span> [a = <span class="number">3</span>, b = a] = [<span class="number">1</span>, <span class="number">2</span>];    <span class="comment">// a = 1, b = 2</span></span><br></pre></td></tr></table></figure><p>交换变量</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">3</span>;</span><br><span class="line">[a, b] = [b, a];</span><br></pre></td></tr></table></figure><h3 id="对象解构"><a href="#对象解构" class="headerlink" title="对象解构"></a>对象解构</h3><p>基本，其中 foo 和 bar 的位置可以随意替换。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; foo, bar &#125; = &#123; <span class="attr">foo</span>: <span class="string">'aaa'</span>, <span class="attr">bar</span>: <span class="string">'bbb'</span> &#125;; <span class="comment">// foo = 'aaa' bar = 'bbb'</span></span><br></pre></td></tr></table></figure><p>给新的变量名赋值，可以从一个对象中提取变量并赋值给和对象属性名不同的新的变量名。其中输出 baz 变量会报错。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; <span class="attr">baz</span> : foo &#125; = &#123; <span class="attr">baz</span> : <span class="string">'ddd'</span> &#125;; <span class="comment">// foo = 'ddd'</span></span><br></pre></td></tr></table></figure><p>可嵌套可忽略</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">p</span>: [<span class="string">'hello'</span>, &#123;<span class="attr">y</span>: <span class="string">'world'</span>&#125;] &#125;;</span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">p</span>: [x, &#123; y &#125;] &#125; = obj;    <span class="comment">// x = 'hello' y = 'world'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">p</span>: [<span class="string">'hello'</span>, &#123;<span class="attr">y</span>: <span class="string">'world'</span>&#125;] &#125;;</span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">p</span>: [x, &#123; &#125;] &#125; = obj;      <span class="comment">// x = 'hello'</span></span><br></pre></td></tr></table></figure><p>不完全解构</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">p</span>: [ &#123; <span class="attr">y</span>: <span class="string">'world'</span> &#125; ] &#125;;</span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">p</span>: [ &#123; y &#125;, x ] &#125; = obj; <span class="comment">// y = 'world' x = undefined</span></span><br></pre></td></tr></table></figure><p>剩余运算符</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; a, b, ...rest &#125; = &#123; <span class="attr">a</span>: <span class="number">10</span>, <span class="attr">b</span>: <span class="number">20</span>, <span class="attr">c</span>: <span class="number">30</span>, <span class="attr">d</span>: <span class="number">40</span> &#125;; <span class="comment">// a = 10 b = 20 rest = &#123; c: 30, d: 40 &#125;</span></span><br></pre></td></tr></table></figure><p>解构默认值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; a = <span class="number">10</span>, b = <span class="number">5</span> &#125; = &#123; <span class="attr">a</span>: <span class="number">3</span> &#125;;           <span class="comment">// a = 3; b = 5;</span></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">a</span>: aa = <span class="number">10</span>, <span class="attr">b</span>: bb = <span class="number">5</span> &#125; = &#123; <span class="attr">a</span>: <span class="number">3</span> &#125;;   <span class="comment">// aa = 3; bb = 5;</span></span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>var 命令也可以解构赋值，遵循 var 相关特性。</li><li>可以运用解构赋值，给函数提供默认值。</li></ul><h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><p>基础使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">( 参数 <span class="number">1</span>, 参数 <span class="number">2</span>, …, 参数 N ) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 函数声明</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数体只有一句可简写</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">( 参数 <span class="number">1</span>, 参数 <span class="number">2</span>, …, 参数 N ) =&gt; 表达式（单一）</span><br><span class="line"><span class="comment">// 相当于</span></span><br><span class="line">( 参数 <span class="number">1</span>, 参数 <span class="number">2</span>, …, 参数 N ) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> 表达式;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当只有一个参数时，圆括号是可选的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(单一参数) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 函数声明</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 相当于</span></span><br><span class="line">单一参数 =&gt; &#123;</span><br><span class="line">    <span class="comment">// 函数声明</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没有参数的函数应该写成一对圆括号。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">() =&gt; &#123;</span><br><span class="line">    函数声明</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加括号的函数体返回对象字面表达式，花括号<code>{}</code>里面的代码被解析为一系列语句（即 foo 被认为是一个标签，而非对象字面量的组成部分），所以，记得用圆括号把对象字面量包起来。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">参数 =&gt; ( &#123;<span class="attr">foo</span>: bar &#125; )</span><br></pre></td></tr></table></figure><p>支持剩余参数和默认参数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">( 参数 <span class="number">1</span>, 参数 <span class="number">2</span>, ...rest ) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 函数声明</span></span><br><span class="line">&#125;</span><br><span class="line">( 参数 <span class="number">1</span> = 默认值 <span class="number">1</span>, 参数 <span class="number">2</span>, …, 参数 N = 默认值 N ) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 函数声明</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样支持参数列表解构</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> f = <span class="function">(<span class="params">[a, b] = [<span class="number">1</span>, <span class="number">2</span>], &#123;x: c&#125; = &#123;x: a + b&#125;</span>) =&gt;</span> a + b + c;</span><br><span class="line"></span><br><span class="line">f();</span><br></pre></td></tr></table></figure><p>注意：使用了块语句的箭头函数不会自动返回值，你需要使用 return 语句将所需值返回。</p><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p>Set 类似于数组，但是成员的值都是唯一的，没有重复的值。</p><p>Set 函数可以接受一个数组（或者具有 iterable 接口的其他数据结构）作为参数，用来初始化。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">set</span> = new Set([1, 2, 3, 4, 4]);</span><br></pre></td></tr></table></figure><p>属性和方法说明：</p><table><thead><tr><th>属性和方法</th><th>说明</th></tr></thead><tbody><tr><td>size</td><td>返回 Set 实例的成员总数。</td></tr><tr><td>add(value)</td><td>添加某个值，返回 Set 结构本身。</td></tr><tr><td>delete(value)</td><td>删除某个值，返回一个布尔值，表示删除是否成功。</td></tr><tr><td>has(value)</td><td>返回一个布尔值，表示该值是否为 Set 的成员。</td></tr><tr><td>clear()</td><td>清除所有成员，没有返回值。</td></tr></tbody></table><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>Map 对象保存键值对。任何值（对象或者原始值） 都可以作为一个键或一个值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"></span><br><span class="line">map.set(<span class="string">"key"</span>,value);</span><br></pre></td></tr></table></figure><p>属性和方法说明：</p><table><thead><tr><th>属性和方法</th><th>说明</th></tr></thead><tbody><tr><td>size</td><td>size 属性返回 Map 结构的成员总数。</td></tr><tr><td>set(key, value)</td><td>设置键名 key 对应的键值为 value，然后返回整个 Map 结构。</td></tr><tr><td>get(key)</td><td>get 方法读取 key 对应的键值，如果找不到 key，返回 undefined。</td></tr><tr><td>has(key)</td><td>has 方法返回一个布尔值，表示某个键是否在当前 Map 对象之中。</td></tr><tr><td>delete(key)</td><td>delete 方法删除某个键，返回 true。如果删除失败，返回 false。</td></tr><tr><td>clear()</td><td>clear 方法清除所有成员，没有返回值。</td></tr></tbody></table><p>注意：set 方法如果 key 已经有值，则键值会被更新，否则就新生成该键。</p><h2 id="class"><a href="#class" class="headerlink" title="class"></a>class</h2><p>class 可以看作只是一个语法糖，写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(x, y) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    toString() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'('</span> + <span class="keyword">this</span>.x + <span class="string">', '</span> + <span class="keyword">this</span>.y + <span class="string">')'</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义“类”的方法的时候，前面不需要加上 function 这个关键字。</p><p>ES6 的类，完全可以看作构造函数的另一种写法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> Point <span class="comment">// "function"</span></span><br></pre></td></tr></table></figure><p>使用的时候，也是直接对类使用 new 命令。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> Point(<span class="number">0</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><h2 id="extends"><a href="#extends" class="headerlink" title="extends"></a>extends</h2><p>class 可以通过 extends 关键字实现继承，这比 ES5 的通过修改原型链实现继承，要清晰和方便很多。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColorPoint</span> <span class="keyword">extends</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(x, y, color) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">super</span>(x, y); <span class="comment">// 调用父类的 constructor(x, y)</span></span><br><span class="line">        <span class="keyword">this</span>.color = color;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    toString() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.color + <span class="string">' '</span> + <span class="keyword">super</span>.toString(); <span class="comment">// 调用父类的 toString()</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>super 关键字表示父类的构造函数，用来新建父类的 this 对象。</li><li>子类必须在 constructor 方法中调用 super 方法，否则新建实例时会报错。</li></ul><h2 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h2><ul><li>模板字符串用反引号（`）标识。</li><li>如果在模板字符串中需要使用反引号，则前面要用反斜杠转义。</li><li>使用模板字符串表示多行字符串，所有的空格和缩进都会被保留在输出之中。</li><li>模板字符串中嵌入变量，需要将变量名写在${}之中。</li></ul><h2 id="延展操作符-…"><a href="#延展操作符-…" class="headerlink" title="延展操作符 (…)"></a>延展操作符 (…)</h2><p>它可以将数组，更确切的说是（可遍历对象）进行展开然后作为函数入参进行调用。</p><p>快速复制一个数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> arr2 = [...arr];</span><br></pre></td></tr></table></figure><p>剩余操作符 <code>(...)</code>，剩余参数允许长度不确定的实参表示为一个数组。</p><h2 id="for…of-循环"><a href="#for…of-循环" class="headerlink" title="for…of 循环"></a>for…of 循环</h2><p>语法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ( variable <span class="keyword">of</span> iterable ) &#123;</span><br><span class="line">    statement</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>variable：每个迭代的属性值被分配给该变量。</li><li>iterable：一个具有可枚举属性并且可以迭代的对象。</li></ul><h2 id="Module-的语法"><a href="#Module-的语法" class="headerlink" title="Module 的语法"></a>Module 的语法</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>历史上，JavaScript 一直没有模块（module）体系，无法将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来。在 ES6 之前，社区制定了一些模块加载方案，最主要的有 CommonJS 和 AMD 两种。前者用于服务器，后者用于浏览器。ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 <strong>CommonJS</strong> 和 <strong>AMD</strong> 规范，成为浏览器和服务器通用的模块解决方案。模块化编程在 js 界流行，随后在浏览器端，requirejs 和 seajs 之类的工具包也出现了，可以说在对应规范下，require 统治了 ES6 之前的所有模块化编程，即使现在，在 ES6 module 被完全实现之前，还是这样。node 的 module 遵循 CommonJS 规范，requirejs 遵循 AMD，seajs 遵循 CMD。</p><h3 id="export-命令"><a href="#export-命令" class="headerlink" title="export 命令"></a>export 命令</h3><p>ES6 的模块自动采用严格模式，不管你有没有在模块头部加上”use strict;”。</p><p>export 命令用于规定模块的对外接口，import 命令用于输入其他模块提供的功能。下面两种写法等价。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// profile.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法 1</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> firstName = <span class="string">'Michael'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> lastName = <span class="string">'Jackson'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> year = <span class="number">1958</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法 2</span></span><br><span class="line"><span class="keyword">var</span> firstName = <span class="string">'Michael'</span>;</span><br><span class="line"><span class="keyword">var</span> lastName = <span class="string">'Jackson'</span>;</span><br><span class="line"><span class="keyword">var</span> year = <span class="number">1958</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123; firstName, lastName, year &#125;;</span><br></pre></td></tr></table></figure><p>export 命令除了输出变量，还可以输出函数或类（class）。</p><p>export 输出的变量就是本来的名字，但是可以使用 as 关键字重命名。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">v1</span>(<span class="params"></span>) </span>&#123; ... &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">v2</span>(<span class="params"></span>) </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123;</span><br><span class="line"></span><br><span class="line">    v1 <span class="keyword">as</span> streamV1,</span><br><span class="line">    v2 <span class="keyword">as</span> streamV2,</span><br><span class="line">    v2 <span class="keyword">as</span> streamLatestVersion</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>export 语句输出的接口，与其对应的值是动态绑定关系，即通过该接口，可以取到模块内部实时的值。</p><p>输出变量 foo，值为 bar，500 毫秒之后变成 baz。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> foo = <span class="string">'bar'</span>;</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> foo = <span class="string">'baz'</span>, <span class="number">500</span>);</span><br></pre></td></tr></table></figure><p>注意：export 处于块级作用域内，就会报错，import 命令也是如此。</p><h3 id="import-命令"><a href="#import-命令" class="headerlink" title="import 命令"></a>import 命令</h3><p>使用 import 命令必须满足下列条件。</p><ul><li>浏览器必须支持 ES6 语法。</li><li>必须在服务器运行。</li><li>&lt;script&gt; 标签中加入 <code>type = &#39;module&#39;</code> 。</li></ul><p>使用 export 命令定义了模块的对外接口以后，其他 JS 文件就可以通过 import 命令加载这个模块。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; firstName, lastName, year &#125; <span class="keyword">from</span> <span class="string">'./profile.js'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setName</span>(<span class="params">element</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    element.textContent = firstName + <span class="string">' '</span> + lastName;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>想为输入的变量重新取一个名字，import 命令要使用 as 关键字，将输入的变量重命名。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; lastName <span class="keyword">as</span> surname &#125; <span class="keyword">from</span> <span class="string">'./profile.js'</span>;</span><br></pre></td></tr></table></figure><ul><li>import 命令输入的变量都是只读的，因为它的本质是输入接口。但对象的属性可以改写并且其他模块也可以读到改写后的值。</li><li>import 后面的 from 指定模块文件的位置，可以是相对路径，也可以是绝对路径，.js 后缀可以省略（谷歌浏览器测试不通过）。</li><li>import 命令具有提升效果，会提升到整个模块的头部。</li></ul><p>除了指定加载某个输出值，还可以使用整体加载，即用星号（*）指定一个对象，所有输出值都加载在这个对象上面。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> circle <span class="keyword">from</span> <span class="string">'./circle'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'圆面积：'</span> + circle.area(<span class="number">4</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'圆周长：'</span> + circle.circumference(<span class="number">14</span>));</span><br></pre></td></tr></table></figure><h3 id="export-default-命令"><a href="#export-default-命令" class="headerlink" title="export default 命令"></a>export default 命令</h3><p>export default 命令用于指定模块的默认输出。</p><p>一个模块只能有一个默认输出，因此 export default 命令只能使用一次。所以import 命令后面才不用加大括号。</p><p>本质上，export default 就是输出一个叫做 default 的变量或方法，然后系统允许你为它取任意名字。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// modules.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> x * y;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> &#123;add <span class="keyword">as</span> <span class="keyword">default</span>&#125;;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> add;</span><br><span class="line"></span><br><span class="line"><span class="comment">// app.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="keyword">default</span> <span class="keyword">as</span> foo &#125; <span class="keyword">from</span> <span class="string">'modules'</span>;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">import</span> foo <span class="keyword">from</span> <span class="string">'modules'</span>;</span><br></pre></td></tr></table></figure><h2 id="对象内部定义函数简写方式"><a href="#对象内部定义函数简写方式" class="headerlink" title="对象内部定义函数简写方式"></a>对象内部定义函数简写方式</h2><p>第一种写法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person1 = &#123;</span><br><span class="line"></span><br><span class="line">    name: <span class="string">"p1"</span>,</span><br><span class="line">    sayThis() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>第二种写法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person2 = &#123;</span><br><span class="line"></span><br><span class="line">    name: <span class="string">"p2"</span>,</span><br><span class="line">    sayThis: <span class="function"><span class="params">()</span>=&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sat Sep 24 2022 00:07:49 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;本文主要介绍 JavaScript 中 ES6 新特性。&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端" scheme="https://zero3737.gitee.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="https://zero3737.gitee.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="教程" scheme="https://zero3737.gitee.io/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="JavaScript" scheme="https://zero3737.gitee.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>渐进增强与优雅降级</title>
    <link href="https://zero3737.gitee.io/posts/b6afdfc/"/>
    <id>https://zero3737.gitee.io/posts/b6afdfc/</id>
    <published>2020-04-20T10:08:41.000Z</published>
    <updated>2020-04-20T10:10:20.861Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Sep 24 2022 00:07:49 GMT+0800 (GMT+08:00) --><p>本文主要介绍渐进增强与优雅降级相关概念。</p><a id="more"></a><hr><h2 id="渐进增强"><a href="#渐进增强" class="headerlink" title="渐进增强"></a>渐进增强</h2><p>一开始针对低版本的浏览器构建页面，满足最基本的功能，再针对高级浏 览器进行效果，交互，追加各种功能以达到更好用户体验。</p><h2 id="优雅降级"><a href="#优雅降级" class="headerlink" title="优雅降级"></a>优雅降级</h2><p>一开始针对一个高版本的浏览器构建页面，先完善所有的功能。然后针对各个不同的浏览器进行测试，修复，保证低级浏览器也有基本功能。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sat Sep 24 2022 00:07:49 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;本文主要介绍渐进增强与优雅降级相关概念。&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端" scheme="https://zero3737.gitee.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="https://zero3737.gitee.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="CSS" scheme="https://zero3737.gitee.io/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>IE 浏览器常见 Bug</title>
    <link href="https://zero3737.gitee.io/posts/b9b74e47/"/>
    <id>https://zero3737.gitee.io/posts/b9b74e47/</id>
    <published>2020-04-20T09:58:52.000Z</published>
    <updated>2020-04-21T19:10:25.141Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Sep 24 2022 00:07:49 GMT+0800 (GMT+08:00) --><p>本文主要列举 IE 浏览器常见 Bug。</p><a id="more"></a><hr><h2 id="透明度问题"><a href="#透明度问题" class="headerlink" title="透明度问题"></a>透明度问题</h2><p>问题描述：opacity 属性无效，必须使用 <code>filter: alpha(opacity=80);</code></p><p>解决方案：设置透明度（取值为 0~100）。</p><h2 id="IE6-双边局问题"><a href="#IE6-双边局问题" class="headerlink" title="IE6 双边局问题"></a>IE6 双边局问题</h2><p>问题描述：元素设置左浮动和左外边距（margin-left），元素距离浏览器左边的距离为左外边距 * 2。</p><p>解决方案：设置 <code>_display: inline;</code> 即可解决。</p><h2 id="IE6-最小高度为-19-px"><a href="#IE6-最小高度为-19-px" class="headerlink" title="IE6 最小高度为 19 px"></a>IE6 最小高度为 19 px</h2><p>解决方案：设置 <code>overflow: hidden;</code> 即可解决。</p><h2 id="图片链接产生边框问题"><a href="#图片链接产生边框问题" class="headerlink" title="图片链接产生边框问题"></a>图片链接产生边框问题</h2><p>问题描述：a 标签中嵌套 img 标签会产生边框。</p><p>解决方案：设置 <code>border: none;</code> 即可解决。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sat Sep 24 2022 00:07:49 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;本文主要列举 IE 浏览器常见 Bug。&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端" scheme="https://zero3737.gitee.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="https://zero3737.gitee.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="CSS" scheme="https://zero3737.gitee.io/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>浏览器前缀</title>
    <link href="https://zero3737.gitee.io/posts/6982a08e/"/>
    <id>https://zero3737.gitee.io/posts/6982a08e/</id>
    <published>2020-04-20T09:56:27.000Z</published>
    <updated>2020-04-20T10:10:20.856Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Sep 24 2022 00:07:49 GMT+0800 (GMT+08:00) --><p>本文主要介绍浏览器前缀，浏览器前缀可以分为 CSS 前缀和选择器前缀。</p><a id="more"></a><hr><h2 id="CSS-前缀"><a href="#CSS-前缀" class="headerlink" title="CSS 前缀"></a>CSS 前缀</h2><table><thead><tr><th>浏览器</th><th>内核</th><th>前缀</th><th>补充</th></tr></thead><tbody><tr><td>Chrome（谷歌浏览器）</td><td>WebKit 内核</td><td>-webkit-</td><td></td></tr><tr><td>Safari（苹果浏览器）</td><td>WebKit 内核</td><td>-webkit-</td><td></td></tr><tr><td>Firefox（火狐浏览器）</td><td>Gecko 内核</td><td>-moz-</td><td></td></tr><tr><td>Opera（欧朋浏览器）</td><td>Presto 内核</td><td>-o-</td><td></td></tr><tr><td>IE(IE 浏览器）</td><td>Trident 内核</td><td>-ms-</td><td></td></tr><tr><td>IE6</td><td>&nbsp;</td><td>_</td><td></td></tr><tr><td>IE6~7</td><td>&nbsp;</td><td>+、*</td><td></td></tr><tr><td>IE6~9</td><td>&nbsp;</td><td>\9</td><td>width: 100px\9;</td></tr><tr><td>IE8~11</td><td>&nbsp;</td><td>\0</td><td>width: 100px\0;</td></tr></tbody></table><h2 id="选择器前缀"><a href="#选择器前缀" class="headerlink" title="选择器前缀"></a>选择器前缀</h2><table><thead><tr><th>浏览器</th><th>前缀</th></tr></thead><tbody><tr><td>IE6</td><td>*html</td></tr><tr><td>IE7</td><td>*+html</td></tr><tr><td>IE9 以上及现代浏览器</td><td>:root</td></tr></tbody></table><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sat Sep 24 2022 00:07:49 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;本文主要介绍浏览器前缀，浏览器前缀可以分为 CSS 前缀和选择器前缀。&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端" scheme="https://zero3737.gitee.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="https://zero3737.gitee.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="CSS" scheme="https://zero3737.gitee.io/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>格式化上下文</title>
    <link href="https://zero3737.gitee.io/posts/451e216f/"/>
    <id>https://zero3737.gitee.io/posts/451e216f/</id>
    <published>2020-04-20T09:52:58.000Z</published>
    <updated>2020-04-20T10:10:20.847Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Sep 24 2022 00:07:49 GMT+0800 (GMT+08:00) --><p>本文主要介绍格式化上下文相关概念以及 BFC 相关特性。</p><a id="more"></a><hr><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>有的盒子呈水平排列，有的盒子却占满整个一行。这是因为不同的盒子，使用的是不同的格式化上下文来布局。</p><p>格式化上下文常见的有两种。</p><ul><li>块格式化上下文（BFC）</li><li>行内格式化上下文（IFC）</li></ul><h2 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h2><p>BFC 是页面上的一个独立容器。</p><p>BFC 属性具有以下特性：</p><ul><li>父元素的外边距（margin）不会受子元素影响。</li><li>同级元素的垂直外边距不会合并。</li><li>不会被浮动元素所覆盖（三栏布局）。</li><li>可以包含浮动元素。不会造成高度塌陷。</li><li>高度塌陷：父元素没有设置高度，高度默认被子元素撑开，一旦子元素脱离文档流，则父元素的高度自动变为 0，造成页面排版混乱。</li></ul><p>BFC 是元素的隐藏属性，默认是关闭状态，开启 BFC 的方式：</p><ul><li>浮动元素，float 除 none 以外的值。</li><li>定位元素，position（absolute，fixed）。</li><li>display 为以下其中之一的值 inline-block, table-cell, table-caption。</li><li>overflow 设置除了 visible 以外的值（hidden, auto, scroll）。</li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sat Sep 24 2022 00:07:49 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;本文主要介绍格式化上下文相关概念以及 BFC 相关特性。&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端" scheme="https://zero3737.gitee.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="https://zero3737.gitee.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="CSS" scheme="https://zero3737.gitee.io/tags/CSS/"/>
    
      <category term="教程" scheme="https://zero3737.gitee.io/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>媒体查询（响应式布局）</title>
    <link href="https://zero3737.gitee.io/posts/cb9ff0ec/"/>
    <id>https://zero3737.gitee.io/posts/cb9ff0ec/</id>
    <published>2020-04-20T09:44:17.000Z</published>
    <updated>2020-04-20T10:10:20.831Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Sep 24 2022 00:07:49 GMT+0800 (GMT+08:00) --><p>本文主要介绍媒体查询（响应式布局）相关属性的使用。</p><a id="more"></a><hr><h2 id="media"><a href="#media" class="headerlink" title="@media"></a>@media</h2><p>使用 @media 查询，你可以针对不同的媒体类型定义不同的样式。</p><p>语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">media</span> mediatype and|not|only (media feature) &#123;</span><br><span class="line">    <span class="selector-tag">CSS-Code</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>媒体类型（mediatype）：</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><code>screen</code></td><td>用于电脑屏幕，平板电脑，智能手机等。</td></tr></tbody></table></li><li><p><code>and</code> 是一个关键字，表示有多个表达式，mediatype 是第一个表达式，and 后为另一个表达式，需前后表达式都为真时，整条查询结构才为真。</p></li><li><p><code>only</code> 指定某种特定的媒体类型，可以用来排除不支持媒体查询的浏览器。</p></li><li><p><code>not</code> 排除某种制定的媒体类型。</p></li><li><p>媒体功能（media feature）：</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><code>min-width</code></td><td>定义输出设备中的页面最小可见区域宽度。</td></tr><tr><td><code>max-width</code></td><td>定义输出设备中的页面最大可见区域宽度。</td></tr></tbody></table></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sat Sep 24 2022 00:07:49 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;本文主要介绍媒体查询（响应式布局）相关属性的使用。&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端" scheme="https://zero3737.gitee.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="https://zero3737.gitee.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="CSS" scheme="https://zero3737.gitee.io/tags/CSS/"/>
    
      <category term="教程" scheme="https://zero3737.gitee.io/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>字体图标</title>
    <link href="https://zero3737.gitee.io/posts/2b320a99/"/>
    <id>https://zero3737.gitee.io/posts/2b320a99/</id>
    <published>2020-04-20T09:42:06.000Z</published>
    <updated>2020-04-20T10:10:20.840Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Sep 24 2022 00:07:49 GMT+0800 (GMT+08:00) --><p>本文主要介绍使用字体图标相关属性。</p><a id="more"></a><hr><h2 id="font-face"><a href="#font-face" class="headerlink" title="@font-face"></a>@font-face</h2><p><code>@font-face</code> 规则允许在 web 页面上加载自定义字体。属性如下：</p><ul><li><code>font-family</code> 必需。规定字体的名称。</li><li><code>src</code> 必需。定义字体文件的 URL。</li><li><code>content</code> 输出的是字符编码，通过字符编码找到字体库对应的字体内容。</li></ul><p>format（字体格式）参数说明。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">font-face</span> &#123;</span><br><span class="line">  <span class="attribute">font-family</span>: <span class="string">"Open Sans"</span>;</span><br><span class="line">  <span class="attribute">src</span>: <span class="built_in">url</span>(<span class="string">"/fonts/OpenSans-Regular-webfont.woff2"</span>) <span class="built_in">format</span>(<span class="string">"woff2"</span>),</span><br><span class="line">       <span class="built_in">url</span>(<span class="string">"/fonts/OpenSans-Regular-webfont.woff"</span>) <span class="built_in">format</span>(<span class="string">"woff"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><code>truetype</code></td><td>.ttf 字体格式是 Windows 和 Mac 的最常见的。</td></tr><tr><td><code>opentype</code></td><td>原始字体格式，内置在 truetype 基础之上。</td></tr><tr><td><code>embedded-opentype</code></td><td>.eot 字体格式是 IE 专用的。</td></tr><tr><td><code>woff</code></td><td>web 字体最佳格式。</td></tr><tr><td><code>woff2</code></td><td>woff2 字体格式。</td></tr><tr><td><code>svg</code></td><td>基于 svg 渲染。</td></tr></tbody></table><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sat Sep 24 2022 00:07:49 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;本文主要介绍使用字体图标相关属性。&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端" scheme="https://zero3737.gitee.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="https://zero3737.gitee.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="CSS" scheme="https://zero3737.gitee.io/tags/CSS/"/>
    
      <category term="教程" scheme="https://zero3737.gitee.io/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>如何将 SVG 图标转换成字体图标？</title>
    <link href="https://zero3737.gitee.io/posts/99b64e40/"/>
    <id>https://zero3737.gitee.io/posts/99b64e40/</id>
    <published>2020-04-20T09:38:36.000Z</published>
    <updated>2020-04-20T10:10:20.825Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Sep 24 2022 00:07:49 GMT+0800 (GMT+08:00) --><p>本文主要介绍如何将 SVG 图标转换成字体图标。</p><a id="more"></a><hr><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><p>首先下载 svg 矢量图标（阿里巴巴矢量图标库），然后通过第三方网站（例如：icomoon）转换成字体图标。得到一个压缩包，把压缩包中的字体文件和 css 文件导入项目中即可使用。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sat Sep 24 2022 00:07:49 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;本文主要介绍如何将 SVG 图标转换成字体图标。&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端" scheme="https://zero3737.gitee.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="https://zero3737.gitee.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="CSS" scheme="https://zero3737.gitee.io/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>CSS 中 @import 语句</title>
    <link href="https://zero3737.gitee.io/posts/b5cd75ce/"/>
    <id>https://zero3737.gitee.io/posts/b5cd75ce/</id>
    <published>2020-04-20T09:36:30.000Z</published>
    <updated>2020-04-23T18:48:16.071Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Sep 24 2022 00:07:49 GMT+0800 (GMT+08:00) --><p>本文主要介绍 @import 语句的作用。</p><a id="more"></a><hr><h2 id="import-语句"><a href="#import-语句" class="headerlink" title="@import 语句"></a>@import 语句</h2><p>@import 规则指示请求样式表，如果内容正确，就会引入一个外部的 CSS 文件。</p><p>语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">import</span> <span class="string">'css 文件路径'</span>;</span><br><span class="line">@<span class="keyword">import</span> url(<span class="string">"css 文件路径"</span>);</span><br></pre></td></tr></table></figure><p>每一个 @import 都是一个独立的 HTPP 请求。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sat Sep 24 2022 00:07:49 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;本文主要介绍 @import 语句的作用。&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端" scheme="https://zero3737.gitee.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="https://zero3737.gitee.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="CSS" scheme="https://zero3737.gitee.io/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>CSS 函数</title>
    <link href="https://zero3737.gitee.io/posts/9a375ea/"/>
    <id>https://zero3737.gitee.io/posts/9a375ea/</id>
    <published>2020-04-20T09:13:50.000Z</published>
    <updated>2020-04-20T10:10:20.796Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Sep 24 2022 00:07:49 GMT+0800 (GMT+08:00) --><p>本文主要介绍 CSS 函数。</p><a id="more"></a><hr><h2 id="函数说明"><a href="#函数说明" class="headerlink" title="函数说明"></a>函数说明</h2><p><code>calc()</code> 函数用于动态计算长度值。</p><ul><li>任何长度值都可以使用 calc() 函数进行计算。</li><li>运算符前后都需要保留一个空格，例如： <code>width: calc(100% - 10px)</code> 。</li><li>calc() 函数支持 “+”, “-“, “*”, “/“ 运算。</li></ul><p><code>linear-gradient(direction, color-stop1, color-stop2, ...);</code> 用于创建一个<strong>线性渐变</strong>的 “图像”。</p><p>该函数需要添加到 background-image 属性上使用。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">    <span class="comment">/* 从右下到左上、从蓝色渐变到红色 */</span></span><br><span class="line">    <span class="attribute">background-image</span>: <span class="built_in">linear-gradient</span>(to left top, blue, red);</span><br><span class="line">    <span class="comment">/* 0 ~ 25% 和 75% ~ 100% 为纯色，25% ~ 75% 为渐变色 */</span></span><br><span class="line">    <span class="attribute">background-image</span>: <span class="built_in">linear-gradient</span>(to left top, blue 25%, red 75%);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>radial-gradient(shape size at position, start-color, ..., last-color);</code> 函数用<strong>径向渐变</strong>创建”图像”。</p><p>该函数需要添加到 background-image 属性上使用。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">    <span class="comment">/* 0 ~ 25% 和 75% ~ 100% 为纯色，25% ~ 75% 为渐变色 */</span></span><br><span class="line">    <span class="attribute">background-image</span>: <span class="built_in">radial-gradient</span>(blue 25%, red 50%, yellow 75%);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sat Sep 24 2022 00:07:49 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;本文主要介绍 CSS 函数。&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端" scheme="https://zero3737.gitee.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="https://zero3737.gitee.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="CSS" scheme="https://zero3737.gitee.io/tags/CSS/"/>
    
      <category term="教程" scheme="https://zero3737.gitee.io/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Flex 布局</title>
    <link href="https://zero3737.gitee.io/posts/1ec02f4f/"/>
    <id>https://zero3737.gitee.io/posts/1ec02f4f/</id>
    <published>2020-04-20T09:09:33.000Z</published>
    <updated>2020-04-20T10:10:20.812Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Sep 24 2022 00:07:49 GMT+0800 (GMT+08:00) --><p>本文主要介绍 Flex 布局中常用的相关属性。</p><a id="more"></a><hr><h2 id="Flex-容器"><a href="#Flex-容器" class="headerlink" title="Flex 容器"></a>Flex 容器</h2><p><code>display:flex;</code> 将对象作为弹性伸缩盒显示。</p><p><code>display:inline-flex;</code> 将对象作为内联块级弹性伸缩盒显示。</p><p><code>flex-flow</code> 属性是 flex-direction 和 flex-wrap 的简写，默认 row nowrap。</p><p><code>flex-direction</code> 用于指定 flex 主轴的方向，继而决定 flex 子项在 flex 容器中的位置。</p><ul><li><code>row</code> 默认值。灵活的项目将水平显示，正如一个行一样，起点在屏幕左边。</li><li><code>row-reverse</code> 与 row 相同，但是以相反的顺序，起点在屏幕右边。</li><li><code>column</code> 灵活的项目将垂直显示，正如一个列一样，起点在屏幕上边。</li><li><code>column-reverse</code> 与 column 相同，但是以相反的顺序，起点在屏幕下边。</li></ul><p><code>flex-wrap</code> 属性规定 flex 容器是单行或者多行，同时横轴的方向决定了新行堆叠的方向。</p><ul><li><code>nowrap</code> 默认值。规定灵活的项目不拆行或不拆列。</li><li><code>wrap</code> 规定灵活的项目在必要的时候拆行或拆列。</li><li><code>wrap-reverse</code> 规定灵活的项目在必要的时候拆行或拆列，但是以相反的顺序。</li></ul><p><code>justify-content</code> 定义项目在主轴上的对齐方式。</p><ul><li><code>flex-start</code> 默认值。项目位于容器的开头。</li><li><code>flex-end</code> 项目位于容器的结尾。</li><li><code>center</code> 项目位于容器的中心。</li><li><code>space-between</code> 两端项目对齐（左边和右边没有间隔），其余项目两侧间隔相等。</li><li><code>space-around</code> 每个项目两侧的间隔相等（左边和右边间隔为 x，其余项目两侧间隔为 2x）。</li></ul><p><code>align-items</code> 属性定义 flex 子项在 flex 容器的当前行的侧轴方向上的对齐方式。</p><ul><li><code>stretch</code> 默认值。元素被拉伸以适应容器。如果设置了长度则不拉伸。</li><li><code>center</code> 元素位于容器侧轴的中心。</li><li><code>flex-start</code> 元素位于容器侧轴的开头。</li><li><code>flex-end</code> 元素位于容器侧轴的结尾。</li><li><code>baseline</code> 元素位于容器的基线上。</li></ul><p><code>align-content</code> 定义多根主轴的对齐方式。</p><ul><li><code>stretch</code> 默认值。元素被拉伸以适应容器。如果设置了长度则不拉伸。</li><li><code>flex-start</code> 元素位于容器侧轴的开头。</li><li><code>flex-end</code> 元素位于容器侧轴的结尾。</li><li><code>center</code> 元素位于容器侧轴的中心。</li><li><code>baseline</code> 元素位于容器的基线上。</li><li><code>space-between</code> 与交叉轴的两端对齐，轴线之间的间隔平均分布。</li><li><code>space-around</code> 每根轴线两侧的间隔相等。</li></ul><h2 id="flex-项目"><a href="#flex-项目" class="headerlink" title="flex 项目"></a>flex 项目</h2><p><code>flex</code> 属性是 flex-grow、flex-shrink 和 flex-basis 属性的简写属性。</p><p><code>flex-grow</code> 属性用于设置或检索弹性盒子的放大比率。</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>number</td><td>一个数字，规定项目将相对于其他项目进行扩展的量。默认值是 0。</td></tr></tbody></table><p><code>flex-shrink</code> 属性定义项目的缩小比例。默认值都为 1，空间不足将等比例缩小。为 0 不缩放。</p><p><code>flex-basis</code> 属性定义在分配多余空间之前，项目占据的主轴空间。</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>number</td><td>一个长度单位（px）或者一个百分比。</td></tr></tbody></table><ul><li>如果元素上同时设置了 width 和 flex-basis，那么 width 的值就会被 flex-basis 覆盖掉。</li><li>width 属性只是一个当 flex-basis 没有被设置时的回退选项。min-width 和 max-width 则是 flex-basis 的下限和上限。</li></ul><p><code>order</code> 属性定义项目的排列顺序。</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>number</td><td>一个整数。数值越小，排列越靠前，默认为 0，可以是负值。</td></tr></tbody></table><p><code>align-self</code> 属性定义 flex 子项单独在侧轴方向上的对齐方式。</p><ul><li><code>auto</code> 默认值。元素继承了它的父容器的 align-items 属性。</li><li><code>stretch</code> 元素被拉伸以适应容器。</li><li><code>flex-start</code> 元素位于容器的开头。</li><li><code>flex-end</code> 元素位于容器的结尾。</li><li><code>center</code> 元素位于容器的中心。</li><li><code>baseline</code> 元素位于容器的基线上。</li></ul><h2 id="flex-布局注意事项"><a href="#flex-布局注意事项" class="headerlink" title="flex 布局注意事项"></a>flex 布局注意事项</h2><ul><li>flex 布局中慎用 position 定位。</li><li>flex 布局中 float 属性失效。</li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sat Sep 24 2022 00:07:49 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;本文主要介绍 Flex 布局中常用的相关属性。&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端" scheme="https://zero3737.gitee.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="https://zero3737.gitee.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="CSS" scheme="https://zero3737.gitee.io/tags/CSS/"/>
    
      <category term="教程" scheme="https://zero3737.gitee.io/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>CSS 动画</title>
    <link href="https://zero3737.gitee.io/posts/19ff9408/"/>
    <id>https://zero3737.gitee.io/posts/19ff9408/</id>
    <published>2020-04-20T08:56:42.000Z</published>
    <updated>2020-04-20T10:10:20.801Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Sep 24 2022 00:07:49 GMT+0800 (GMT+08:00) --><p>本文主要介绍 CSS 相关动画属性。</p><a id="more"></a><hr><h2 id="CSS-动画"><a href="#CSS-动画" class="headerlink" title="CSS 动画"></a>CSS 动画</h2><p>CSS3 动画只兼容 IE9 以上。</p><p><code>transform</code> 属性向元素应用 2D 或 3D 转换。该属性允许我们对元素进行旋转、缩放、移动或倾斜。</p><ul><li><code>scaleX(x)</code> 通过设置 X 轴的值来定义缩放转换。</li><li><code>scaleY(y)</code> 通过设置 Y 轴的值来定义缩放转换。</li><li><code>scale(x,y)</code> 设置 x, y 轴的值来定义缩放转换。</li><li><code>translateX(x)</code> x 轴移动。</li><li><code>translateY(y)</code> y 轴移动。</li><li><code>translate(x,y)</code> x, y 轴移动。</li><li><code>rotateX(angle)</code> 定义沿着 X 轴的 3D 旋转。angle 参数：-180deg（-180 度）。</li><li><code>rotateY(angle)</code> 定义沿着 Y 轴的 3D 旋转。</li><li><code>rotate(angle)</code> 定义 2D 旋转，在参数中规定角度。</li></ul><p><code>transform-origin</code> 属性是用来改变元素变形的原点，一般用来配合旋转来使用最多。</p><ul><li>注意：该属性必须与 transform 属性一同使用。</li><li>语法：transform-origin: x-axis y-axis z-axis;</li></ul><table><thead><tr><th>参数</th><th>说明</th><th>可选参数</th></tr></thead><tbody><tr><td><code>x-axis</code></td><td>定义视图被置于 X 轴的何处。</td><td>left、 center、 right、 length、 %</td></tr><tr><td><code>y-axis</code></td><td>定义视图被置于 Y 轴的何处。</td><td>top、 center、 bottom、 length、 %</td></tr></tbody></table><p><code>transition</code> 属性是一个简写属性，用于设置四个过渡属性：</p><p><code>transition-property</code> 规定设置过渡效果的 CSS 属性的名称。</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><code>none</code></td><td>没有属性会获得过渡效果。</td></tr><tr><td><code>all</code></td><td>所有属性都将获得过渡效果。</td></tr></tbody></table><ul><li>transition-property 值为 all 时，不管元素是否具有 transfrom 属性，只要元素发生改变，都会获得过渡效果。</li><li>过渡效果添加在哪个元素上，取决于是哪个元素需要过渡效果。</li></ul><p><code>transition-duration</code> 规定完成过渡效果需要多少秒或毫秒。</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>time</td><td>规定完成过渡效果需要花费的时间（以秒或毫秒计）。默认值是 0。</td></tr></tbody></table><p><code>transition-timing-function</code> 规定速度效果的速度曲线。</p><ul><li><code>linear</code> 规定以相同速度开始至结束的过渡效果。</li><li><code>ease</code> 规定慢速开始，然后变快，然后慢速结束的过渡效果。</li><li><code>ease-in</code> 规定以慢速开始的过渡效果。</li><li><code>ease-out</code> 规定以慢速结束的过渡效果。</li><li><code>ease-in-out</code> 规定以慢速开始和结束的过渡效果。</li><li><code>cubic-bezier(n,n,n,n)</code> 在 cubic-bezier 函数中定义自己的值。可能的值是 0 至 1 之间的数值。</li></ul><p><code>transition-delay</code> 定义过渡效果何时开始。</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>time</td><td>规定在过渡效果开始之前需要等待的时间，以秒或毫秒计。</td></tr></tbody></table><h2 id="3D-相关属性"><a href="#3D-相关属性" class="headerlink" title="3D 相关属性"></a>3D 相关属性</h2><p><code>transform-style</code> 属性规定如何在 3D 空间中呈现被嵌套的元素。</p><ul><li><code>flat</code> 子元素将不保留其 3D 位置。</li><li><code>preserve-3d</code> 子元素将保留其 3D 位置（3D 空间）。</li></ul><p><code>perspective</code> 属性定义 3D 元素距视图的距离，以像素计。</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>number</td><td>元素距离视图的距离，以像素计。</td></tr><tr><td>none</td><td>默认值，与 0 相同，不设置透视。</td></tr></tbody></table><ul><li>当为元素定义 perspective 属性时，其子元素会获得透视效果，而不是元素本身。</li><li>相当于创建一台照相机，number 值越大，元素与照相机距离越近，效果越明显。</li></ul><p>perspective-origin 定义 3D 元素基于的 X 轴和 Y 轴（改变摄像机的位置）。</p><ul><li>语法： <code>perspective-origin: x-axis y-axis;</code></li></ul><table><thead><tr><th>参数</th><th>说明</th><th>可选参数</th></tr></thead><tbody><tr><td>x-axis</td><td>定义该视图在 x 轴上的位置。默认值：50%。</td><td>left、center、right、length、%</td></tr><tr><td>y-axis</td><td>定义该视图在 y 轴上的位置。默认值：50%。</td><td></td></tr></tbody></table><p><code>backface-visibility</code> 属性定义当元素不面向屏幕时是否可见。</p><ul><li><code>visible</code> 背面是可见的。</li><li><code>hidden</code> 背面是不可见的。</li></ul><h2 id="自定义动画"><a href="#自定义动画" class="headerlink" title="自定义动画"></a>自定义动画</h2><p>通过 @keyframes 规则，您能够创建动画。创建动画的原理是，将一套 CSS 样式逐渐变化为另一套样式。以百分比来规定改变发生的时间，或者通过关键词 “from” 和 “to”，等价于 0% 和 100%。0% 是动画的开始时间，100% 动画的结束时间。</p><p>语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">keyframes</span> animationname &#123;</span><br><span class="line">    <span class="selector-tag">keyframes-selector</span> &#123;</span><br><span class="line">        css-styles;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>animationname</code> 必需。定义动画的名称。</p></li><li><p><code>keyframes-selector</code> 必需。动画时长的百分比。</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><code>0-100%</code></td><td></td></tr><tr><td><code>from</code></td><td>与 0% 相同</td></tr><tr><td><code>to</code></td><td>与 100% 相同</td></tr></tbody></table></li><li><p><code>css-styles</code> 必需。一个或多个合法的 CSS 样式属性。</p></li></ul><p><code>animation</code> 属性是一个简写属性，用于设置以下六个动画属性。</p><ul><li><p><code>animation-name</code> 规定需要绑定到选择器的 keyframe 名称。</p></li><li><p><code>animation-duration</code> 规定完成动画所花费的时间，以秒或毫秒计。</p></li><li><p><code>animation-timing-function</code> 规定动画的速度曲线。</p></li><li><p><code>animation-delay</code> 规定在动画开始之前的延迟。</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>time</td><td>可选。定义动画开始前等待的时间，以秒或毫秒计。默认值是 0。</td></tr></tbody></table></li><li><p><code>animation-iteration-count</code> 规定动画应该播放的次数。</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>n</td><td>定义动画播放次数的数值。</td></tr><tr><td><code>infinite</code></td><td>规定动画应该无限次播放。</td></tr></tbody></table></li><li><p><code>animation-direction</code> 规定是否应该轮流反向播放动画。</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><code>normal</code></td><td>默认值。动画应该正常播放。</td></tr><tr><td><code>alternate</code></td><td>动画应该轮流反向播放。</td></tr></tbody></table></li></ul><p><code>animation-fill-mode</code> 规定当动画不播放时要应用到元素的样式。</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>forwards</td><td>在动画结束后，动画将应用动画结束的属性值。</td></tr></tbody></table><p><code>animation-play-state</code> 规定动画正在运行还是暂停。</p><ul><li><code>paused</code> 规定动画已暂停。</li><li><code>running</code> 规定动画正在播放。</li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sat Sep 24 2022 00:07:49 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;本文主要介绍 CSS 相关动画属性。&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端" scheme="https://zero3737.gitee.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="https://zero3737.gitee.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="CSS" scheme="https://zero3737.gitee.io/tags/CSS/"/>
    
      <category term="教程" scheme="https://zero3737.gitee.io/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Grid网格布局</title>
    <link href="https://zero3737.gitee.io/posts/d97530e8/"/>
    <id>https://zero3737.gitee.io/posts/d97530e8/</id>
    <published>2020-04-20T08:20:31.000Z</published>
    <updated>2020-04-21T19:05:28.473Z</updated>
    
    <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <div class="hbe-input-container">  <input type="password" id="hbePass" placeholder="" />    <label for="hbePass">输入密码，查看文章。</label>    <div class="bottom-line"></div>  </div>  <script id="hbeData" type="hbeData" data-hmacdigest="2b4313a1fae8600c61fcfc514362eef21e5b898b1c660e8bc76d7ce1f1d86c7e">01118a64dfdab291d98e66adcd8332c5ae07b832bab2f2fb2adc7f8a903582147f908f8b8133758992dcb3d67d5c8f81b60be15159c999d3bf3c358f15dc86ef261c078570d40c10217e2a51965a1dadb0ff376b7a1aa471c615bd8c083e8265</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      这是一篇加密文章，内容可能是个人情感宣泄或者收费技术。如果你确实想看，请与我联系。
    
    </summary>
    
    
      <category term="前端" scheme="https://zero3737.gitee.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="https://zero3737.gitee.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="CSS" scheme="https://zero3737.gitee.io/tags/CSS/"/>
    
      <category term="未完待续" scheme="https://zero3737.gitee.io/tags/%E6%9C%AA%E5%AE%8C%E5%BE%85%E7%BB%AD/"/>
    
  </entry>
  
</feed>
